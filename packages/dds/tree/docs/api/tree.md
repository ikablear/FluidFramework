{
  "title": "@fluid-internal/tree Package",
  "kind": "Package",
  "members": {
    "TypeAlias": {
      "Anchor": "/docs/apis/tree#anchor-typealias",
      "Brand": "/docs/apis/tree#brand-typealias",
      "ChangesetLocalId": "/docs/apis/tree#changesetlocalid-typealias",
      "ChildCollection": "/docs/apis/tree#childcollection-typealias",
      "ContextuallyTypedNodeData": "/docs/apis/tree#contextuallytypednodedata-typealias",
      "EditableTreeOrPrimitive": "/docs/apis/tree#editabletreeorprimitive-typealias",
      "ExtractFromOpaque": "/docs/apis/tree#extractfromopaque-typealias",
      "FieldChangeMap": "/docs/apis/tree#fieldchangemap-typealias",
      "FieldChangeset": "/docs/apis/tree#fieldchangeset-typealias",
      "FieldKey": "/docs/apis/tree#fieldkey-typealias",
      "FieldKindIdentifier": "/docs/apis/tree#fieldkindidentifier-typealias",
      "ForestLocation": "/docs/apis/tree#forestlocation-typealias",
      "GlobalFieldKey": "/docs/apis/tree#globalfieldkey-typealias",
      "GlobalFieldKeySymbol": "/docs/apis/tree#globalfieldkeysymbol-typealias",
      "IdAllocator": "/docs/apis/tree#idallocator-typealias",
      "isAny": "/docs/apis/tree#isany-typealias",
      "JsonCompatible": "/docs/apis/tree#jsoncompatible-typealias",
      "JsonCompatibleObject": "/docs/apis/tree#jsoncompatibleobject-typealias",
      "JsonCompatibleReadOnly": "/docs/apis/tree#jsoncompatiblereadonly-typealias",
      "LocalFieldKey": "/docs/apis/tree#localfieldkey-typealias",
      "NamedTreeSchema": "/docs/apis/tree#namedtreeschema-typealias",
      "NameFromBranded": "/docs/apis/tree#namefrombranded-typealias",
      "NodeChangeComposer": "/docs/apis/tree#nodechangecomposer-typealias",
      "NodeChangeDecoder": "/docs/apis/tree#nodechangedecoder-typealias",
      "NodeChangeEncoder": "/docs/apis/tree#nodechangeencoder-typealias",
      "NodeChangeInverter": "/docs/apis/tree#nodechangeinverter-typealias",
      "NodeChangeRebaser": "/docs/apis/tree#nodechangerebaser-typealias",
      "NodeReviver": "/docs/apis/tree#nodereviver-typealias",
      "Opaque": "/docs/apis/tree#opaque-typealias",
      "PrimitiveValue": "/docs/apis/tree#primitivevalue-typealias",
      "RevisionTag": "/docs/apis/tree#revisiontag-typealias",
      "ToDelta": "/docs/apis/tree#todelta-typealias",
      "TreeSchemaIdentifier": "/docs/apis/tree#treeschemaidentifier-typealias",
      "TreeType": "/docs/apis/tree#treetype-typealias",
      "TreeTypeSet": "/docs/apis/tree#treetypeset-typealias",
      "UnwrappedEditableField": "/docs/apis/tree#unwrappededitablefield-typealias",
      "UnwrappedEditableTree": "/docs/apis/tree#unwrappededitabletree-typealias",
      "Value": "/docs/apis/tree#value-typealias",
      "ValueChange": "/docs/apis/tree#valuechange-typealias",
      "ValueFromBranded": "/docs/apis/tree#valuefrombranded-typealias"
    },
    "Interface": {
      "AnchorLocator": "/docs/apis/tree/anchorlocator-interface",
      "ChangeFamily": "/docs/apis/tree/changefamily-interface",
      "ChangeRebaser": "/docs/apis/tree/changerebaser-interface",
      "ChildLocation": "/docs/apis/tree/childlocation-interface",
      "ContextuallyTypedNodeDataObject": "/docs/apis/tree/contextuallytypednodedataobject-interface",
      "Contravariant": "/docs/apis/tree/contravariant-interface",
      "Covariant": "/docs/apis/tree/covariant-interface",
      "Dependee": "/docs/apis/tree/dependee-interface",
      "Dependent": "/docs/apis/tree/dependent-interface",
      "DetachedField": "/docs/apis/tree/detachedfield-interface",
      "EditableField": "/docs/apis/tree/editablefield-interface",
      "EditableTree": "/docs/apis/tree/editabletree-interface",
      "EditableTreeContext": "/docs/apis/tree/editabletreecontext-interface",
      "FieldAnchor": "/docs/apis/tree/fieldanchor-interface",
      "FieldChange": "/docs/apis/tree/fieldchange-interface",
      "FieldChangeEncoder": "/docs/apis/tree/fieldchangeencoder-interface",
      "FieldChangeHandler": "/docs/apis/tree/fieldchangehandler-interface",
      "FieldChangeRebaser": "/docs/apis/tree/fieldchangerebaser-interface",
      "FieldEditor": "/docs/apis/tree/fieldeditor-interface",
      "FieldLocation": "/docs/apis/tree/fieldlocation-interface",
      "FieldMapObject": "/docs/apis/tree/fieldmapobject-interface",
      "FieldSchema": "/docs/apis/tree/fieldschema-interface",
      "FieldUpPath": "/docs/apis/tree/fielduppath-interface",
      "FullSchemaPolicy": "/docs/apis/tree/fullschemapolicy-interface",
      "GenericFieldsNode": "/docs/apis/tree/genericfieldsnode-interface",
      "GenericTreeNode": "/docs/apis/tree/generictreenode-interface",
      "ICheckout": "/docs/apis/tree/icheckout-interface",
      "IDefaultEditBuilder": "/docs/apis/tree/idefaulteditbuilder-interface",
      "IEditableForest": "/docs/apis/tree/ieditableforest-interface",
      "IForestSubscription": "/docs/apis/tree/iforestsubscription-interface",
      "Invariant": "/docs/apis/tree/invariant-interface",
      "ISharedTree": "/docs/apis/tree/isharedtree-interface",
      "ITreeCursor": "/docs/apis/tree/itreecursor-interface",
      "ITreeCursorSynchronous": "/docs/apis/tree/itreecursorsynchronous-interface",
      "ITreeSubscriptionCursor": "/docs/apis/tree/itreesubscriptioncursor-interface",
      "JsonableTree": "/docs/apis/tree/jsonabletree-interface",
      "MakeNominal": "/docs/apis/tree/makenominal-interface",
      "MarkedArrayLike": "/docs/apis/tree/markedarraylike-interface",
      "ModularChangeset": "/docs/apis/tree/modularchangeset-interface",
      "Named": "/docs/apis/tree/named-interface",
      "NamedComputation": "/docs/apis/tree/namedcomputation-interface",
      "NodeChangeset": "/docs/apis/tree/nodechangeset-interface",
      "NodeData": "/docs/apis/tree/nodedata-interface",
      "ObservingDependent": "/docs/apis/tree/observingdependent-interface",
      "OptionalFieldEditBuilder": "/docs/apis/tree/optionalfieldeditbuilder-interface",
      "ProgressiveEditBuilder": "/docs/apis/tree/progressiveeditbuilder-interface",
      "ReadonlyRepairDataStore": "/docs/apis/tree/readonlyrepairdatastore-interface",
      "RepairDataStore": "/docs/apis/tree/repairdatastore-interface",
      "RootField": "/docs/apis/tree/rootfield-interface",
      "SchemaData": "/docs/apis/tree/schemadata-interface",
      "SchemaDataAndPolicy": "/docs/apis/tree/schemadataandpolicy-interface",
      "SchemaPolicy": "/docs/apis/tree/schemapolicy-interface",
      "SequenceFieldEditBuilder": "/docs/apis/tree/sequencefieldeditbuilder-interface",
      "StoredSchemaRepository": "/docs/apis/tree/storedschemarepository-interface",
      "TaggedChange": "/docs/apis/tree/taggedchange-interface",
      "TreeLocation": "/docs/apis/tree/treelocation-interface",
      "TreeSchema": "/docs/apis/tree/treeschema-interface",
      "TreeValue": "/docs/apis/tree/treevalue-interface",
      "UpPath": "/docs/apis/tree/uppath-interface",
      "ValueFieldEditBuilder": "/docs/apis/tree/valuefieldeditbuilder-interface"
    },
    "Class": {
      "AnchorSet": "/docs/apis/tree/anchorset-class",
      "BrandedType": "/docs/apis/tree/brandedtype-class",
      "ChangeEncoder": "/docs/apis/tree/changeencoder-class",
      "FieldKind": "/docs/apis/tree/fieldkind-class",
      "InvalidationToken": "/docs/apis/tree/invalidationtoken-class",
      "ModularChangeFamily": "/docs/apis/tree/modularchangefamily-class",
      "ModularEditBuilder": "/docs/apis/tree/modulareditbuilder-class",
      "ProgressiveEditBuilderBase": "/docs/apis/tree/progressiveeditbuilderbase-class",
      "SharedTreeFactory": "/docs/apis/tree/sharedtreefactory-class",
      "SimpleDependee": "/docs/apis/tree/simpledependee-class"
    },
    "Function": {
      "brand": "/docs/apis/tree#brand-function",
      "brandOpaque": "/docs/apis/tree#brandopaque-function",
      "buildForest": "/docs/apis/tree#buildforest-function",
      "cursorToJsonObject": "/docs/apis/tree#cursortojsonobject-function",
      "extractFromOpaque": "/docs/apis/tree#extractfromopaque-function",
      "getPrimaryField": "/docs/apis/tree#getprimaryfield-function",
      "isContextuallyTypedNodeDataObject": "/docs/apis/tree#iscontextuallytypednodedataobject-function",
      "isEditableField": "/docs/apis/tree#iseditablefield-function",
      "isGlobalFieldKey": "/docs/apis/tree#isglobalfieldkey-function",
      "isNeverField": "/docs/apis/tree#isneverfield-function",
      "isPrimitive": "/docs/apis/tree#isprimitive-function",
      "isPrimitiveValue": "/docs/apis/tree#isprimitivevalue-function",
      "isUnwrappedNode": "/docs/apis/tree#isunwrappednode-function",
      "isWritableArrayLike": "/docs/apis/tree#iswritablearraylike-function",
      "jsonableTreeFromCursor": "/docs/apis/tree#jsonabletreefromcursor-function",
      "keyFromSymbol": "/docs/apis/tree#keyfromsymbol-function",
      "recordDependency": "/docs/apis/tree#recorddependency-function",
      "singleJsonCursor": "/docs/apis/tree#singlejsoncursor-function",
      "symbolFromKey": "/docs/apis/tree#symbolfromkey-function",
      "symbolIsFieldKey": "/docs/apis/tree#symbolisfieldkey-function"
    },
    "Variable": {
      "createField": "/docs/apis/tree#createfield-variable",
      "defaultSchemaPolicy": "/docs/apis/tree#defaultschemapolicy-variable",
      "emptyField": "/docs/apis/tree#emptyfield-variable",
      "EmptyKey": "/docs/apis/tree#emptykey-variable",
      "getField": "/docs/apis/tree#getfield-variable",
      "indexSymbol": "/docs/apis/tree#indexsymbol-variable",
      "jsonArray": "/docs/apis/tree#jsonarray-variable",
      "jsonBoolean": "/docs/apis/tree#jsonboolean-variable",
      "jsonNull": "/docs/apis/tree#jsonnull-variable",
      "jsonNumber": "/docs/apis/tree#jsonnumber-variable",
      "jsonObject": "/docs/apis/tree#jsonobject-variable",
      "jsonSchemaData": "/docs/apis/tree#jsonschemadata-variable",
      "jsonString": "/docs/apis/tree#jsonstring-variable",
      "neverTree": "/docs/apis/tree#nevertree-variable",
      "proxyTargetSymbol": "/docs/apis/tree#proxytargetsymbol-variable",
      "replaceField": "/docs/apis/tree#replacefield-variable",
      "rootFieldKey": "/docs/apis/tree#rootfieldkey-variable",
      "typeNameSymbol": "/docs/apis/tree#typenamesymbol-variable",
      "typeSymbol": "/docs/apis/tree#typesymbol-variable",
      "valueSymbol": "/docs/apis/tree#valuesymbol-variable"
    },
    "Enum": {
      "CursorLocationType": "/docs/apis/tree#cursorlocationtype-enum",
      "FieldScope": "/docs/apis/tree#fieldscope-enum",
      "ITreeSubscriptionCursorState": "/docs/apis/tree#itreesubscriptioncursorstate-enum",
      "Multiplicity": "/docs/apis/tree#multiplicity-enum",
      "TransactionResult": "/docs/apis/tree#transactionresult-enum",
      "TreeNavigationResult": "/docs/apis/tree#treenavigationresult-enum",
      "ValueSchema": "/docs/apis/tree#valueschema-enum"
    },
    "Namespace": {
      "Delta": "/docs/apis/tree/delta-namespace",
      "SequenceField": "/docs/apis/tree/sequencefield-namespace"
    }
  },
  "package": "@fluid-internal/tree",
  "unscopedPackageName": "tree"
}

[//]: # (Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter.)

[Packages](/docs/apis/) &gt; [@fluid-internal/tree](/docs/apis/tree)

## Interfaces

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Interface
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/anchorlocator-interface'>AnchorLocator</a>
      </td>
      <td>
        Maps anchors (which must be ones this locator knows about) to paths.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/changefamily-interface'>ChangeFamily</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/changerebaser-interface'>ChangeRebaser</a>
      </td>
      <td>
        <p>Rebasing logic for a particular kind of change.</p><p>This interface is used to provide rebase policy to <code>Rebaser</code>.</p><p>The implementation must ensure TChangeset forms a [group](https://en.wikipedia.org/wiki/Group_(mathematics)) where: - <code>compose([])</code> is the identity element. - associativity is defined as <code>compose([...a, ...b])</code> is equal to <code>compose([compose(a), compose(b)])</code> for all <code>a</code> and <code>b</code>. - <code>inverse(a)</code> gives the inverse element of <code>a</code>.</p><p>In these requirements the definition of equality is up to the implementer, but it is required that any two changes which are considered equal: - have the same impact when applied to any tree. - can be substituted for each-other in all methods on this interface and produce equal (by this same definition) results.</p><p>For the sake of testability, implementations will likely want to have a concrete equality implementation.</p><p>This API uses <code>compose</code> on arrays instead of an explicit identity element and associative binary operator to allow the implementation more room for optimization, but should otherwise be equivalent to the identity element and binary operator group approach.</p><p>TODO: Be more specific about the above requirements. For example, would something that is close to forming a group but has precision issues (ex: the floating point numbers and addition) be ok? Would this cause decoherence (and thus be absolutely not ok), or just minor semantic precision issues, which could be tolerated. For now assume that such issues are not ok.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/childlocation-interface'>ChildLocation</a>
      </td>
      <td>
        Location of a tree relative to is parent container (which can be a tree or forest).
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/contextuallytypednodedataobject-interface'>ContextuallyTypedNodeDataObject</a>
      </td>
      <td>
        Object case of <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/contravariant-interface'>Contravariant</a>
      </td>
      <td>
        Constrain generic type parameters to Contravariant.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/covariant-interface'>Covariant</a>
      </td>
      <td>
        Constrain generic type parameters to Covariant.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/dependee-interface'>Dependee</a>
      </td>
      <td>
        <p>Interface for object which can change and invalidate <a href='/docs/apis/tree/dependent-interface'>Dependent</a>s when changing. Tracks a set of <code>Dependent</code>s on which <a href='/docs/apis/tree/dependent-interface#markinvalid-methodsignature'>Dependent.markInvalid()</a> will be called when the output of this changes.</p><p>Dependencies are only used for invalidation, so there is no need to make a <code>Dependee</code> when the source data is immutable.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/dependent-interface'>Dependent</a>
      </td>
      <td>
        <p>Object that can depend on <a href='/docs/apis/tree/dependee-interface'>Dependee</a>s.</p><p>Provides a callback (<a href='/docs/apis/tree/dependent-interface#markinvalid-methodsignature'>Dependent.markInvalid()</a>) for the <code>Dependee</code> to invoke when it is invalidated.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/detachedfield-interface'>DetachedField</a>
      </td>
      <td>
        <p>A root in the forest.</p><p>The range is a "container" like a field: any additional content inserted before or after contents of this range will be included in the range. This also means that moving the content from this range elsewhere will leave this range valid, but empty.</p><p>DetachedFields are not valid to use as across edits: they are only valid within the edit in which they were created.</p><p>In some APIs DetachedFields are used as LocalFieldKeys on a special implicit root node to simplify the APIs and implementation.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>
      </td>
      <td>
        <p>A field of an <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> as an array-like sequence of unwrapped nodes (see <a href='/docs/apis/tree#unwrappededitabletree-typealias'>UnwrappedEditableTree</a>).</p><p>The number of nodes depends on a field's multiplicity. When iterating, the nodes are read at once. Use index access to read the nodes "lazily". Use <code>getNode</code> to get a node without unwrapping.</p><p>It is possible to create/replace a node or to set its value by using the simple assignment operator (<code>=</code>) and providing an input data as a <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a>. See <code>EditableTreeContext.unwrappedRoot</code> for more details, as it works the same way for all children of the tree starting from its root.</p><p>It is forbidden to delete the node using the <code>delete</code> operator, use the <code>deleteNodes()</code> method instead.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a>
      </td>
      <td>
        <p>A tree which can be traversed and edited.</p><p>When iterating, only visits non-empty fields. To discover empty fields, inspect the schema using <a href='/docs/apis/tree#typesymbol-variable'>typeSymbol</a>.</p><p>The tree can be inspected by means of the built-in JS functions e.g.</p>
        ```
        const root = context.unwrappedRoot;
        for (const key of Reflect.ownKeys(root)) { ... }
        // OR
        if ("foo" in root) { ... }
        ```
        <p>where <code>context</code> is a common <code>EditableTreeContext</code>.</p><p>The tree can be edited either by using its symbol-based "toolbox" (e.g. <a href='/docs/apis/tree#createfield-variable'>createField</a>) or using a simple assignment operator (see <code>EditableTreeContext.unwrappedRoot</code> for more details).</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletreecontext-interface'>EditableTreeContext</a>
      </td>
      <td>
        A common context of a "forest" of EditableTrees. It handles group operations like transforming cursors into anchors for edits.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldanchor-interface'>FieldAnchor</a>
      </td>
      <td>
        Anchor to a field. This is structurally based on the parent, so it will move only as the parent moves.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldchange-interface'>FieldChange</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldchangeencoder-interface'>FieldChangeEncoder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldchangehandler-interface'>FieldChangeHandler</a>
      </td>
      <td>
        Functionality provided by a field kind which will be composed with other <code>FieldChangeHandler</code>s to implement a unified ChangeFamily supporting documents with multiple field kinds.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldchangerebaser-interface'>FieldChangeRebaser</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldeditor-interface'>FieldEditor</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldlocation-interface'>FieldLocation</a>
      </td>
      <td>
        Wrapper around DetachedField that can be detected at runtime.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldmapobject-interface'>FieldMapObject</a>
      </td>
      <td>
        <p>Json compatible map as object. Keys are FieldKey strings. Values are the content of the field specified by the key.</p><p>WARNING: Be very careful when using objects as maps: Use <code>Object.prototype.hasOwnProperty.call(fieldMap, key)</code> to safely check for keys. Do NOT simply read the field and check for undefined as this will return values for <code>__proto__</code> and various methods on Object.prototype, like <code>hasOwnProperty</code> and <code>toString</code>. This exposes numerous bug possibilities, including prototype pollution.</p><p>Due to the above issue, try to avoid this type (and the whole object as map pattern). Only use this type when needed for json compatible maps, but even in those cases consider lists of key value pairs for serialization and using <code>Map</code> for runtime.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fielduppath-interface'>FieldUpPath</a>
      </td>
      <td>
        <p>Path from a field in the tree upward.</p><p>See <a href='/docs/apis/tree/uppath-interface'>UpPath</a>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fullschemapolicy-interface'>FullSchemaPolicy</a>
      </td>
      <td>
        Policy from the app for interpreting the stored schema. The app must ensure consistency for all users of the document.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/genericfieldsnode-interface'>GenericFieldsNode</a>
      </td>
      <td>
        Json comparable field collection, generic over child type. Json compatibility assumes <code>TChild</code> is also json compatible.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/generictreenode-interface'>GenericTreeNode</a>
      </td>
      <td>
        Json comparable tree node, generic over child type. Json compatibility assumes <code>TChild</code> is also json compatible.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/icheckout-interface'>ICheckout</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/idefaulteditbuilder-interface'>IDefaultEditBuilder</a>
      </td>
      <td>
        Default editor for transactions.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/ieditableforest-interface'>IEditableForest</a>
      </td>
      <td>
        Editing APIs.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/iforestsubscription-interface'>IForestSubscription</a>
      </td>
      <td>
        <p>Invalidates whenever <code>current</code> changes. For now (might change later) downloading new parts of the forest counts as a change.</p><p>When invalidating, all outstanding cursors must be freed or cleared.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/invariant-interface'>Invariant</a>
      </td>
      <td>
        Constrain generic type parameters to Invariant.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/isharedtree-interface'>ISharedTree</a>
      </td>
      <td>
        <p>Collaboratively editable tree distributed data-structure, powered by <i>@fluidframework/shared-object-base#ISharedObject</i>.</p><p>See [the README](../../README.md) for details.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a>
      </td>
      <td>
        A stateful low-level interface for reading tree data.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/itreecursorsynchronous-interface'>ITreeCursorSynchronous</a>
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a> that is never pending.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/itreesubscriptioncursor-interface'>ITreeSubscriptionCursor</a>
      </td>
      <td>
        ITreeCursor supporting IForestSubscription and its changes over time.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/jsonabletree-interface'>JsonableTree</a>
      </td>
      <td>
        <p>A tree represented using plain JavaScript objects. Can be passed to <code>JSON.stringify()</code> to produce a human-readable/editable JSON tree.</p><p>JsonableTrees should not store empty fields.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/makenominal-interface'>MakeNominal</a>
      </td>
      <td>
        <p>Use this as the type of a protected field to cause a type to use nominal typing instead of structural.</p><p>See: <a href='https://dev.azure.com/intentional/intent/_wiki/wikis/NP%20Platform/7146/Nominal-vs-Structural-Types'>https://dev.azure.com/intentional/intent/_wiki/wikis/NP%20Platform/7146/Nominal-vs-Structural-Types</a></p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/markedarraylike-interface'>MarkedArrayLike</a>
      </td>
      <td>
        Can be used to mark a type which works like an array, but is not compatible with <code>Array.isArray</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/modularchangeset-interface'>ModularChangeset</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/named-interface'>Named</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/namedcomputation-interface'>NamedComputation</a>
      </td>
      <td>
        Computation, with a name.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/nodechangeset-interface'>NodeChangeset</a>
      </td>
      <td>
        Changeset for a subtree rooted at a specific node.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/nodedata-interface'>NodeData</a>
      </td>
      <td>
        The fields required by a node in a tree.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/observingdependent-interface'>ObservingDependent</a>
      </td>
      <td>
        A dependent which can have observations it makes recorded onto it.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/optionalfieldeditbuilder-interface'>OptionalFieldEditBuilder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/progressiveeditbuilder-interface'>ProgressiveEditBuilder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/readonlyrepairdatastore-interface'>ReadonlyRepairDataStore</a>
      </td>
      <td>
        An object that can queried for document data that was deleted in prior revisions.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/repairdatastore-interface'>RepairDataStore</a>
      </td>
      <td>
        An object that captures document data being deleted by changes, and can be queried to retrieve that data.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/rootfield-interface'>RootField</a>
      </td>
      <td>
        Wrapper around DetachedField that can be detected at runtime.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a>
      </td>
      <td>
        <p>View of schema data that can be stored in a document.</p><p>Note: the owner of this may modify it over time: thus if needing to hand onto a specific version, make a copy.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/schemadataandpolicy-interface'>SchemaDataAndPolicy</a>
      </td>
      <td>
        A <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a> with a <a href='/docs/apis/tree/schemapolicy-interface'>SchemaPolicy</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/schemapolicy-interface'>SchemaPolicy</a>
      </td>
      <td>
        Policy from the app for interpreting the stored schema. The app must ensure consistency for all users of the document.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/sequencefieldeditbuilder-interface'>SequenceFieldEditBuilder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/storedschemarepository-interface'>StoredSchemaRepository</a>
      </td>
      <td>
        <p>Mutable collection of stored schema.</p><p>TODO: could implement more fine grained dependency tracking.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/taggedchange-interface'>TaggedChange</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treelocation-interface'>TreeLocation</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treevalue-interface'>TreeValue</a>
      </td>
      <td>
        <p>Value that may be stored on a node.</p><p>TODO: <code>Serializable</code> is not really the right type to use here, since many types (including functions) are "Serializable" (according to the type) despite not being serializable.</p><p>Use this type instead of directly using Serializable for both clarity and so the above TODO can be addressed.</p><p>This is a named interface instead of a Type alias so tooling (ex: refactors) will not replace it with <code>any</code>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a>
      </td>
      <td>
        <p>Path from a location in the tree upward. UpPaths can be used with deduplicated upper parts to allow working with paths localized to part of the tree without incurring costs related to the depth of the local subtree.</p><p>UpPaths can be thought of as terminating at a special root node (that is <code>undefined</code>) who's FieldKeys are all LocalFieldKey's that correspond to detached sequences.</p><p>UpPaths can be mutated over time and should be considered to be invalidated when any edits occurs: Use of an UpPath that was acquired before the most recent edit is undefined behavior.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/valuefieldeditbuilder-interface'>ValueFieldEditBuilder</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Classes

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Class
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/anchorset-class'>AnchorSet</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        <p>Collection of Anchors at a specific revision.</p><p>See <code>Rebaser</code> for how to update across revisions.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/brandedtype-class'>BrandedType</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        <p>Helper for <a href='/docs/apis/tree#brand-typealias'>Brand</a>. This is split out into its own as thats the only way to: - have doc comments for the field. - make the field protected (so you don't accidentally try and read it). - get nominal typing (so types produced without using this class can never be assignable to it). - allow use as <a href='/docs/apis/tree#opaque-typealias'>Opaque</a> branded type (not assignable to <code>ValueType</code>, but captures <code>ValueType</code>).</p><p>See <a href='/docs/apis/tree/makenominal-interface'>MakeNominal</a> for some more details.</p><p>Do not use this class with <code>instanceof</code>: this will always be false at runtime, but the compiler may think its true in some cases.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/changeencoder-class'>ChangeEncoder</a>
      </td>
      <td>
      </td>
      <td>
        <p>Serializes and deserializes changes. Supports both binary and JSON formats. Due to data using these formats being persisted in documents, any format for encoding that was ever actually used should be supported for decoding for all future versions.</p><p>TODO: Nothing in here is specific to changes. Maybe make this interface more general.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkind-class'>FieldKind</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        <p>Functionality for FieldKinds that is stable, meaning that it can not change in any measurable way without providing a new identifier.</p><p>It is assumed that this information and policy is available on all clients interacting with a document using the identifier.</p><p>This must contain enough information to process remote edits to this FieldKind consistently with all clients. All behavior must be deterministic, and not change across versions of the app/library.</p><p>These policies include the data encoding, change encoding, change rebase and change application.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/invalidationtoken-class'>InvalidationToken</a>
      </td>
      <td>
      </td>
      <td>
        Type for providing optional extra data to <a href='/docs/apis/tree/dependent-interface#markinvalid-methodsignature'>Dependent.markInvalid()</a>. Particular instances and/or subclasses can be used to indicate invalidations that can optionally be handled less conservatively than the base invalidated case.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/modularchangefamily-class'>ModularChangeFamily</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        Implementation of ChangeFamily which delegates work in a given field to the appropriate FieldKind as determined by the schema.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/modulareditbuilder-class'>ModularEditBuilder</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/progressiveeditbuilderbase-class'>ProgressiveEditBuilderBase</a>
      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/sharedtreefactory-class'>SharedTreeFactory</a>
      </td>
      <td>
      </td>
      <td>
        A channel factory that creates <a href='/docs/apis/tree/isharedtree-interface'>ISharedTree</a>s.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/simpledependee-class'>SimpleDependee</a>
      </td>
      <td>
      </td>
      <td>
        Simple implementation of <a href='/docs/apis/tree/dependee-interface'>Dependee</a>.
      </td>
    </tr>
  </tbody>
</table>

## Enumerations

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Enum
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#cursorlocationtype-enum'>CursorLocationType</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldscope-enum'>FieldScope</a>
      </td>
      <td>
        The scope of a <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#itreesubscriptioncursorstate-enum'>ITreeSubscriptionCursorState</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-enum'>Multiplicity</a>
      </td>
      <td>
        <p>Describes how a particular field functions.</p><p>This determine its reading and editing APIs, multiplicity, and what merge resolution policies it will use.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#transactionresult-enum'>TransactionResult</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treenavigationresult-enum'>TreeNavigationResult</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-enum'>ValueSchema</a>
      </td>
      <td>
        <p>Example for how we might want to handle values.</p><p>This might be significantly different if we want to focus more on binary formats (need to work out how Fluid GC would work with that). For now, this is a simple easy to support setup.</p><p>Note that use of non-Nothing values might be restricted in the actual user facing schema languages: we could instead choose to get by with the only types supporting values being effectively builtin, though this limitation could prevent users for updating/extending the primitive schema to allow the annotations they might want.</p><p>An interesting alternative to this simple value Enum would be to use something more expressive here, like JsonSchema: since this is modeling immutable data, we really just need a way to figure out which if these value schema allow super sets of each-other.</p><p>TODO: come up with a final design for how to handle primitives / values. This design is just a placeholder.</p>
      </td>
    </tr>
  </tbody>
</table>

## Types

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        TypeAlias
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#anchor-typealias'>Anchor</a>
      </td>
      <td>
        A way to refer to a particular tree location within an <a href='/docs/apis/tree/anchorset-class'>AnchorSet</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#brand-typealias'>Brand</a>
      </td>
      <td>
        <p>Constructs a "Branded" type, adding a type-checking only field to <code>ValueType</code>.</p><p>Two usages of <code>Brand</code> should never use the same <code>Name</code>. If they do, the resulting types will be assignable which defeats the point of this type.</p><p>This type is constructed such that the first line of type errors when assigning mismatched branded types will be: <code>Type 'Name1' is not assignable to type 'Name2'.</code></p><p>These branded types are not opaque: A <code>Brand&lt;A, B&gt;</code> can still be used as a <code>B</code>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#changesetlocalid-typealias'>ChangesetLocalId</a>
      </td>
      <td>
        An ID which is unique within a revision of a <code>ModularChangeset</code>. A <code>ModularChangeset</code> which is a composition of multiple revisions may contain duplicate <code>ChangesetLocalId</code>s, but they are unique when qualified by the revision of the change they are used in.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#childcollection-typealias'>ChildCollection</a>
      </td>
      <td>
        Identifier for a child collection, either on a node/tree or at the root of a forest.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a>
      </td>
      <td>
        <p>Content of a tree which needs external schema information to interpret.</p><p>This format is intended for concise authoring of tree literals when the schema is statically known.</p><p>Once schema aware APIs are implemented, they can be used to provide schema specific subsets of this type.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#editabletreeorprimitive-typealias'>EditableTreeOrPrimitive</a>
      </td>
      <td>
        EditableTree, but with any type that <code>isPrimitive</code> unwrapped into the value if that value is a <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#extractfromopaque-typealias'>ExtractFromOpaque</a>
      </td>
      <td>
        See <a href='/docs/apis/tree#extractfromopaque-function'>extractFromOpaque()</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldchangemap-typealias'>FieldChangeMap</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldchangeset-typealias'>FieldChangeset</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
        <p>Either LocalFieldKey or GlobalFieldKey.</p><p>To avoid collisions, we can not abstract over local and global field keys using the same format for each (that would make telling them apart impossible). Thus global field keys are using their symbols instead.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldkindidentifier-typealias'>FieldKindIdentifier</a>
      </td>
      <td>
        Identifier for a FieldKind. Refers to an exact stable policy (ex: specific version of a policy), for how to handle (ex: edit and merge edits to) fields marked with this kind. Persisted in documents as part of stored schema.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#forestlocation-typealias'>ForestLocation</a>
      </td>
      <td>
        Ways to refer to a node in an IEditableForest.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#globalfieldkey-typealias'>GlobalFieldKey</a>
      </td>
      <td>
        SchemaIdentifier for a "global field", meaning a field which has the same meaning for all usages within the document (not scoped to a specific TreeSchema like LocalFieldKey).
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
        <p>Symbol which can be used to lookup a global field. Using a symbol here avoids the need to use the full string version of the key, and avoids the possibility of colliding with local field keys.</p><p>Must only be produced using <a href='/docs/apis/tree#symbolfromkey-function'>symbolFromKey()</a>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#idallocator-typealias'>IdAllocator</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isany-typealias'>isAny</a>
      </td>
      <td>
        Returns a type parameter that is true iff T is any.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsoncompatible-typealias'>JsonCompatible</a>
      </td>
      <td>
        <p>Use for Json compatible data.</p><p>Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsoncompatibleobject-typealias'>JsonCompatibleObject</a>
      </td>
      <td>
        <p>Use for Json object compatible data.</p><p>Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsoncompatiblereadonly-typealias'>JsonCompatibleReadOnly</a>
      </td>
      <td>
        <p>Use for readonly view of Json compatible data.</p><p>Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#localfieldkey-typealias'>LocalFieldKey</a>
      </td>
      <td>
        Key (aka Name or Label) for a field which is scoped to a specific TreeSchema.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#namedtreeschema-typealias'>NamedTreeSchema</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#namefrombranded-typealias'>NameFromBranded</a>
      </td>
      <td>
        Implementation detail of type branding. Should not be used directly outside this file, but shows up as part of branded types so API-Extractor requires it to be exported.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangecomposer-typealias'>NodeChangeComposer</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangedecoder-typealias'>NodeChangeDecoder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangeencoder-typealias'>NodeChangeEncoder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangeinverter-typealias'>NodeChangeInverter</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangerebaser-typealias'>NodeChangeRebaser</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodereviver-typealias'>NodeReviver</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#opaque-typealias'>Opaque</a>
      </td>
      <td>
        <p>Converts a Branded type into an "opaque" handle. This prevents the value from being used directly, but does not fully type erase it (and this its not really fully opaque): The type can be recovered using <a href='/docs/apis/tree#extractfromopaque-function'>extractFromOpaque()</a>, however if we assume only code that produces these "opaque" handles does that conversion, they can function like opaque handles.</p><p>Recommenced usage is to use <code>interface</code> instead of <code>type</code> so tooling (such as tsc and refactoring tools) uses the type name instead of expanding it:</p>
        ```typescript
        export interface MyType extends Opaque<Brand<string, "myPackage.MyType">>{}
        ```
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#revisiontag-typealias'>RevisionTag</a>
      </td>
      <td>
        A way to refer to a particular revision within a given <code>Rebaser</code> instance.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#todelta-typealias'>ToDelta</a>
      </td>
      <td>
        The <code>index</code> represents the index of the child node in the input context. The <code>index</code> should be <code>undefined</code> iff the child node does not exist in the input context (e.g., an inserted node).
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treeschemaidentifier-typealias'>TreeSchemaIdentifier</a>
      </td>
      <td>
        SchemaIdentifier for a Tree. Also known as "Definition"
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treetype-typealias'>TreeType</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treetypeset-typealias'>TreeTypeSet</a>
      </td>
      <td>
        <p>Set of allowed tree types. Providing multiple values here allows polymorphism, tagged union style.</p><p>If not specified, types are unconstrained (equivalent to the set containing every TreeSchemaIdentifier defined in the document).</p><p>Note that even when unconstrained, children must still be in-schema for their own type.</p><p>In the future, this could be extended to allow inlining a TreeSchema here (or some similar structural schema system). For structural types which could go here, there are a few interesting options:</p><p>- Allow replacing the whole set with a structural type for terminal / non-tree data, and use this as a replacement for values on the tree nodes.</p><p>- Allow expression structural constraints for child trees, for example requiring specific traits (ex: via TreeSchema), instead of by type.</p><p>There are two ways this could work:</p><p>- Constrain the child nodes based on their shape: this makes schema safe editing difficult because nodes would incur extra editing constraints to prevent them from going out of schema based on their location in such a field.</p><p>- Constrain the types allowed based on which types guarantee their data will always meet the constraints.</p><p>Care would need to be taken to make sure this is sound for the schema updating mechanisms.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#unwrappededitablefield-typealias'>UnwrappedEditableField</a>
      </td>
      <td>
        Unwrapped field. Non-sequence multiplicities are unwrapped to the child tree or <code>undefined</code> if there is none. Sequence multiplicities are handled with <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>. See <a href='/docs/apis/tree#unwrappededitabletree-typealias'>UnwrappedEditableTree</a> for how the children themselves are unwrapped.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#unwrappededitabletree-typealias'>UnwrappedEditableTree</a>
      </td>
      <td>
        EditableTree, but with these cases of unwrapping: - primitives are unwrapped. See <a href='/docs/apis/tree#editabletreeorprimitive-typealias'>EditableTreeOrPrimitive</a>. - nodes with PrimaryField (see <code>getPrimaryField</code>) are unwrapped to <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>s. - fields are unwrapped based on their schema's multiplicity. See <a href='/docs/apis/tree#unwrappededitablefield-typealias'>UnwrappedEditableField</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#value-typealias'>Value</a>
      </td>
      <td>
        Value stored on a node.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valuechange-typealias'>ValueChange</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valuefrombranded-typealias'>ValueFromBranded</a>
      </td>
      <td>
        Implementation detail of type branding. Should not be used directly outside this file, but shows up as part of branded types so API-Extractor requires it to be exported.
      </td>
    </tr>
  </tbody>
</table>

## Functions

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Function
      </th>
      <th scope="col">
        Return Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#brand-function'>brand</a>
      </td>
      <td>
        T
      </td>
      <td>
        <p>Adds a type <a href='/docs/apis/tree#brand-typealias'>Brand</a> to a value.</p><p>Only do this when specifically allowed by the requirements of the type being converted to.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#brandopaque-function'>brandOpaque</a>
      </td>
      <td>
        <a href='/docs/apis/tree/brandedtype-class'>BrandedType</a><<a href='/docs/apis/tree#valuefrombranded-typealias'>ValueFromBranded</a><T>, <a href='/docs/apis/tree#namefrombranded-typealias'>NameFromBranded</a><T>>
      </td>
      <td>
        <p>Adds a type <a href='/docs/apis/tree#brand-typealias'>Brand</a> to a value, returning it as a <a href='/docs/apis/tree#opaque-typealias'>Opaque</a> handle.</p><p>Only do this when specifically allowed by the requirements of the type being converted to.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#buildforest-function'>buildForest</a>
      </td>
      <td>
        <a href='/docs/apis/tree/ieditableforest-interface'>IEditableForest</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#cursortojsonobject-function'>cursorToJsonObject</a>
      </td>
      <td>
        <a href='/docs/apis/tree#jsoncompatible-typealias'>JsonCompatible</a>
      </td>
      <td>
        Extract a JS object tree from the contents of the given ITreeCursor. Assumes that ITreeCursor contains only unaugmented JsonTypes.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#extractfromopaque-function'>extractFromOpaque</a>
      </td>
      <td>
        <a href='/docs/apis/tree#extractfromopaque-typealias'>ExtractFromOpaque</a><TOpaque>
      </td>
      <td>
        <p>Converts a <a href='/docs/apis/tree#opaque-typealias'>Opaque</a> handle to the underlying branded type.</p><p>It is assumed that only code that produces these "opaque" handles does this conversion, allowing these handles to be considered opaque.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#getprimaryfield-function'>getPrimaryField</a>
      </td>
      <td>
        { key: <a href='/docs/apis/tree#localfieldkey-typealias'>LocalFieldKey</a>; schema: <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>; } | undefined
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#iscontextuallytypednodedataobject-function'>isContextuallyTypedNodeDataObject</a>
      </td>
      <td>
        data is <a href='/docs/apis/tree/contextuallytypednodedataobject-interface'>ContextuallyTypedNodeDataObject</a>
      </td>
      <td>
        Checks the type of a <code>ContextuallyTypedNodeData</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#iseditablefield-function'>isEditableField</a>
      </td>
      <td>
        field is <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>
      </td>
      <td>
        Checks the type of an UnwrappedEditableField.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isglobalfieldkey-function'>isGlobalFieldKey</a>
      </td>
      <td>
        key is <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
        Derives the scope using the type of <code>key</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isneverfield-function'>isNeverField</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isprimitive-function'>isPrimitive</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isprimitivevalue-function'>isPrimitiveValue</a>
      </td>
      <td>
        nodeValue is <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isunwrappednode-function'>isUnwrappedNode</a>
      </td>
      <td>
        field is <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a>
      </td>
      <td>
        Checks the type of an UnwrappedEditableField.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#iswritablearraylike-function'>isWritableArrayLike</a>
      </td>
      <td>
        data is <a href='/docs/apis/tree/markedarraylike-interface'>MarkedArrayLike</a><<a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a>>
      </td>
      <td>
        Checks the type of a <code>ContextuallyTypedNodeData</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonabletreefromcursor-function'>jsonableTreeFromCursor</a>
      </td>
      <td>
        <a href='/docs/apis/tree/jsonabletree-interface'>JsonableTree</a>
      </td>
      <td>
        Extract a JsonableTree from the contents of the given ITreeCursor's current node.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#keyfromsymbol-function'>keyFromSymbol</a>
      </td>
      <td>
        <a href='/docs/apis/tree#globalfieldkey-typealias'>GlobalFieldKey</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#recorddependency-function'>recordDependency</a>
      </td>
      <td>
        void
      </td>
      <td>
        Ensures this context's computation is a dependant to dependee (adding it if needed). Ensures this context's computation has dependee as a dependee (adding it if needed).
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#singlejsoncursor-function'>singleJsonCursor</a>
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursorsynchronous-interface'>ITreeCursorSynchronous</a>
      </td>
      <td>
        Used to read a Jsonable tree for testing and benchmarking.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#symbolfromkey-function'>symbolFromKey</a>
      </td>
      <td>
        <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#symbolisfieldkey-function'>symbolIsFieldKey</a>
      </td>
      <td>
        key is <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Variables

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Variable
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#createfield-variable'>createField</a>
      </td>
      <td>
        A symbol to get the function, which creates a new field of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a>, in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#defaultschemapolicy-variable'>defaultSchemaPolicy</a>
      </td>
      <td>
        <p>FullSchemaPolicy the default field kinds, empty default fields and neverTree for the default tree schema.</p><p>This requires new node types to have explicit stored schema to exist in documents, and allows adding new global fields along with their schema at any point.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#emptyfield-variable'>emptyField</a>
      </td>
      <td>
        FieldSchema which is impossible to put anything in.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#emptykey-variable'>EmptyKey</a>
      </td>
      <td>
        <p>The empty key ("") is used for unnamed relationships, such as the indexer of an explicit array node.</p><p>This key is a hint that this field is the primary function of the node, and in some abstractions the APIs for this field should be inlined onto the node.</p><p>TODO: This has to be a LocalFieldKey since different nodes will have different FieldSchema for it. This makes it prone to collisions and suggests that this intention may be better conveyed by metadata on the TreeViewSchema.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#getfield-variable'>getField</a>
      </td>
      <td>
        A symbol to get the function, which returns the field of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> without unwrapping, in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#indexsymbol-variable'>indexSymbol</a>
      </td>
      <td>
        A symbol to get the index of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> within its parent field in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonarray-variable'>jsonArray</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonboolean-variable'>jsonBoolean</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonnull-variable'>jsonNull</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonnumber-variable'>jsonNumber</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonobject-variable'>jsonObject</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonschemadata-variable'>jsonSchemaData</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonstring-variable'>jsonString</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nevertree-variable'>neverTree</a>
      </td>
      <td>
        TreeSchema which is impossible for any data to be in schema with.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#proxytargetsymbol-variable'>proxyTargetSymbol</a>
      </td>
      <td>
        A symbol for extracting target from <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> proxies. Useful for debugging and testing, but not part of the public API.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#replacefield-variable'>replaceField</a>
      </td>
      <td>
        A symbol to get the function, which replaces a field of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a>, in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#rootfieldkey-variable'>rootFieldKey</a>
      </td>
      <td>
        GlobalFieldKey to use for the root of documents. TODO: if we do want to standardize on a single value for this, it likely should be namespaced or a UUID to avoid risk of collisions.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#typenamesymbol-variable'>typeNameSymbol</a>
      </td>
      <td>
        A symbol to get the type name of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#typesymbol-variable'>typeSymbol</a>
      </td>
      <td>
        A symbol to get the type of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valuesymbol-variable'>valueSymbol</a>
      </td>
      <td>
        <p>A symbol to get and set the value of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> in contexts where string keys are already in use for fields.</p><p>Setting the value using the simple assignment operator (<code>=</code>) is only supported for <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>s. Concurrently setting the value will follow the "last-write-wins" semantics.</p>
      </td>
    </tr>
  </tbody>
</table>

## Namespaces

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Namespace
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/delta-namespace'>Delta</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/sequencefield-namespace'>SequenceField</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Enumeration Details

### CursorLocationType {#cursorlocationtype-enum}

#### Signature {#cursorlocationtype-signature}

```typescript
export declare const enum CursorLocationType 
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#cursorlocationtype-fields-enummember'>Fields</a>
      </td>
      <td>
        Can iterate through fields of a node. At a "current field".
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#cursorlocationtype-nodes-enummember'>Nodes</a>
      </td>
      <td>
        Can iterate through nodes in a field. At a "current node".
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Fields {#cursorlocationtype-fields-enummember}

Can iterate through fields of a node. At a "current field".

###### Signature {#fields-signature}

```typescript
Fields = 1
```

##### Nodes {#cursorlocationtype-nodes-enummember}

Can iterate through nodes in a field. At a "current node".

###### Signature {#nodes-signature}

```typescript
Nodes = 0
```

### FieldScope {#fieldscope-enum}

The scope of a [FieldKey](/docs/apis/tree#fieldkey-typealias)<!-- -->.

#### Signature {#fieldscope-signature}

```typescript
export declare const enum FieldScope 
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldscope-global-enummember'>global</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldscope-local-enummember'>local</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### global {#fieldscope-global-enummember}

###### Signature {#global-signature}

```typescript
global = "globalFields"
```

##### local {#fieldscope-local-enummember}

###### Signature {#local-signature}

```typescript
local = "fields"
```

### ITreeSubscriptionCursorState {#itreesubscriptioncursorstate-enum}

#### Signature {#itreesubscriptioncursorstate-signature}

```typescript
export declare enum ITreeSubscriptionCursorState 
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#itreesubscriptioncursorstate-cleared-enummember'>Cleared</a>
      </td>
      <td>
        Empty, but can be reused.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#itreesubscriptioncursorstate-current-enummember'>Current</a>
      </td>
      <td>
        On the current revision of the forest.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#itreesubscriptioncursorstate-freed-enummember'>Freed</a>
      </td>
      <td>
        Freed and must not be used.
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Cleared {#itreesubscriptioncursorstate-cleared-enummember}

Empty, but can be reused.

###### Signature {#cleared-signature}

```typescript
Cleared = 1
```

##### Current {#itreesubscriptioncursorstate-current-enummember}

On the current revision of the forest.

###### Signature {#current-signature}

```typescript
Current = 0
```

##### Freed {#itreesubscriptioncursorstate-freed-enummember}

Freed and must not be used.

###### Signature {#freed-signature}

```typescript
Freed = 2
```

### Multiplicity {#multiplicity-enum}

Describes how a particular field functions.

This determine its reading and editing APIs, multiplicity, and what merge resolution policies it will use.

#### Signature {#multiplicity-signature}

```typescript
export declare enum Multiplicity 
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-forbidden-enummember'>Forbidden</a>
      </td>
      <td>
        <p>Exactly 0 items.</p><p>Using Forbidden makes what types are listed for allowed in a field irrelevant since the field will never have values in it.</p><p>Using Forbidden is equivalent to picking a kind that permits empty (like sequence or optional) and having no allowed types (or only never types). Because of this, its possible to express everything constraint wise without Forbidden, but using Forbidden can be more semantically clear than optional with no allowed types.</p><p>For view schema, this can be useful if you need to: - run a specific out of schema handler when a field is present, but otherwise are ignoring or tolerating (ex: via extra fields) unmentioned fields. - prevent a specific field from being used as an extra field (perhaps for some past of future compatibility reason) - keep a field in a schema for metadata purposes (ex: for improved error messaging, error handling or documentation) that is not used in this specific version of the schema (ex: to document what it was or will be used for).</p><p>For stored schema, this can be useful if you need to: - have a field which can have its schema updated to Optional or Sequence of any type. - to exclude a field from extra fields - for the schema system to use as a default for fields which aren't declared (ex: when updating a field that did not exist into one that does)</p><p>See <a href='/docs/apis/tree#emptyfield-variable'>emptyField</a> for a constant, reusable field using Forbidden.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-optional-enummember'>Optional</a>
      </td>
      <td>
        0 or 1 items.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-sequence-enummember'>Sequence</a>
      </td>
      <td>
        0 or more items.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-value-enummember'>Value</a>
      </td>
      <td>
        Exactly one item.
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Forbidden {#multiplicity-forbidden-enummember}

Exactly 0 items.

Using Forbidden makes what types are listed for allowed in a field irrelevant since the field will never have values in it.

Using Forbidden is equivalent to picking a kind that permits empty (like sequence or optional) and having no allowed types (or only never types). Because of this, its possible to express everything constraint wise without Forbidden, but using Forbidden can be more semantically clear than optional with no allowed types.

For view schema, this can be useful if you need to: - run a specific out of schema handler when a field is present, but otherwise are ignoring or tolerating (ex: via extra fields) unmentioned fields. - prevent a specific field from being used as an extra field (perhaps for some past of future compatibility reason) - keep a field in a schema for metadata purposes (ex: for improved error messaging, error handling or documentation) that is not used in this specific version of the schema (ex: to document what it was or will be used for).

For stored schema, this can be useful if you need to: - have a field which can have its schema updated to Optional or Sequence of any type. - to exclude a field from extra fields - for the schema system to use as a default for fields which aren't declared (ex: when updating a field that did not exist into one that does)

See [emptyField](/docs/apis/tree#emptyfield-variable) for a constant, reusable field using Forbidden.

###### Signature {#forbidden-signature}

```typescript
Forbidden = 3
```

##### Optional {#multiplicity-optional-enummember}

0 or 1 items.

###### Signature {#optional-signature}

```typescript
Optional = 1
```

##### Sequence {#multiplicity-sequence-enummember}

0 or more items.

###### Signature {#sequence-signature}

```typescript
Sequence = 2
```

##### Value {#multiplicity-value-enummember}

Exactly one item.

###### Signature {#value-signature}

```typescript
Value = 0
```

### TransactionResult {#transactionresult-enum}

#### Signature {#transactionresult-signature}

```typescript
export declare enum TransactionResult 
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#transactionresult-abort-enummember'>Abort</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#transactionresult-apply-enummember'>Apply</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Abort {#transactionresult-abort-enummember}

###### Signature {#abort-signature}

```typescript
Abort = 0
```

##### Apply {#transactionresult-apply-enummember}

###### Signature {#apply-signature}

```typescript
Apply = 1
```

### TreeNavigationResult {#treenavigationresult-enum}

#### Signature {#treenavigationresult-signature}

```typescript
export declare const enum TreeNavigationResult 
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#treenavigationresult-notfound-enummember'>NotFound</a>
      </td>
      <td>
        Attempt to navigate cursor to a key or index that is outside the client's view.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treenavigationresult-ok-enummember'>Ok</a>
      </td>
      <td>
        ITreeReader successfully navigated to the desired node.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treenavigationresult-pending-enummember'>Pending</a>
      </td>
      <td>
        Attempt to navigate cursor to a portion of the tree that has not yet been loaded.
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### NotFound {#treenavigationresult-notfound-enummember}

Attempt to navigate cursor to a key or index that is outside the client's view.

###### Signature {#notfound-signature}

```typescript
NotFound = -1
```

##### Ok {#treenavigationresult-ok-enummember}

ITreeReader successfully navigated to the desired node.

###### Signature {#ok-signature}

```typescript
Ok = 1
```

##### Pending {#treenavigationresult-pending-enummember}

Attempt to navigate cursor to a portion of the tree that has not yet been loaded.

###### Signature {#pending-signature}

```typescript
Pending = 0
```

### ValueSchema {#valueschema-enum}

Example for how we might want to handle values.

This might be significantly different if we want to focus more on binary formats (need to work out how Fluid GC would work with that). For now, this is a simple easy to support setup.

Note that use of non-Nothing values might be restricted in the actual user facing schema languages: we could instead choose to get by with the only types supporting values being effectively builtin, though this limitation could prevent users for updating/extending the primitive schema to allow the annotations they might want.

An interesting alternative to this simple value Enum would be to use something more expressive here, like JsonSchema: since this is modeling immutable data, we really just need a way to figure out which if these value schema allow super sets of each-other.

TODO: come up with a final design for how to handle primitives / values. This design is just a placeholder.

#### Signature {#valueschema-signature}

```typescript
export declare enum ValueSchema 
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-boolean-enummember'>Boolean</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-nothing-enummember'>Nothing</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-number-enummember'>Number</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-serializable-enummember'>Serializable</a>
      </td>
      <td>
        <p>Any Fluid serializable data.</p><p>This includes Nothing / undefined.</p><p>If it is desired to not include Nothing here, <code>anyNode</code> and <code>allowsValueSuperset</code> would need adjusting.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-string-enummember'>String</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Boolean {#valueschema-boolean-enummember}

###### Signature {#boolean-signature}

```typescript
Boolean = 3
```

##### Nothing {#valueschema-nothing-enummember}

###### Signature {#nothing-signature}

```typescript
Nothing = 0
```

##### Number {#valueschema-number-enummember}

###### Signature {#number-signature}

```typescript
Number = 1
```

##### Serializable {#valueschema-serializable-enummember}

Any Fluid serializable data.

This includes Nothing / undefined.

If it is desired to not include Nothing here, `anyNode` and `allowsValueSuperset` would need adjusting.

###### Signature {#serializable-signature}

```typescript
Serializable = 4
```

##### String {#valueschema-string-enummember}

###### Signature {#string-signature}

```typescript
String = 2
```

## Type Details

### Anchor {#anchor-typealias}

A way to refer to a particular tree location within an [AnchorSet](/docs/apis/tree/anchorset-class)<!-- -->.

#### Signature {#anchor-signature}

```typescript
export declare type Anchor = Brand<number, "rebaser.Anchor">;
```

### Brand {#brand-typealias}

Constructs a "Branded" type, adding a type-checking only field to `ValueType`<!-- -->.

Two usages of `Brand` should never use the same `Name`<!-- -->. If they do, the resulting types will be assignable which defeats the point of this type.

This type is constructed such that the first line of type errors when assigning mismatched branded types will be: `Type 'Name1' is not assignable to type 'Name2'.`

These branded types are not opaque: A `Brand<A, B>` can still be used as a `B`<!-- -->.

#### Signature {#brand-signature}

```typescript
export declare type Brand<ValueType, Name extends string> = ValueType & BrandedType<ValueType, Name>;
```

### ChangesetLocalId {#changesetlocalid-typealias}

An ID which is unique within a revision of a `ModularChangeset`<!-- -->. A `ModularChangeset` which is a composition of multiple revisions may contain duplicate `ChangesetLocalId`<!-- -->s, but they are unique when qualified by the revision of the change they are used in.

#### Signature {#changesetlocalid-signature}

```typescript
export declare type ChangesetLocalId = Brand<number, "ChangesetLocalId">;
```

### ChildCollection {#childcollection-typealias}

Identifier for a child collection, either on a node/tree or at the root of a forest.

#### Signature {#childcollection-signature}

```typescript
export declare type ChildCollection = FieldKey | RootField;
```

### ContextuallyTypedNodeData {#contextuallytypednodedata-typealias}

Content of a tree which needs external schema information to interpret.

This format is intended for concise authoring of tree literals when the schema is statically known.

Once schema aware APIs are implemented, they can be used to provide schema specific subsets of this type.

#### Signature {#contextuallytypednodedata-signature}

```typescript
export declare type ContextuallyTypedNodeData = ContextuallyTypedNodeDataObject | PrimitiveValue | readonly ContextuallyTypedNodeData[] | MarkedArrayLike<ContextuallyTypedNodeData>;
```

### EditableTreeOrPrimitive {#editabletreeorprimitive-typealias}

EditableTree, but with any type that `isPrimitive` unwrapped into the value if that value is a [PrimitiveValue](/docs/apis/tree#primitivevalue-typealias)<!-- -->.

#### Signature {#editabletreeorprimitive-signature}

```typescript
export declare type EditableTreeOrPrimitive = EditableTree | PrimitiveValue;
```

### ExtractFromOpaque {#extractfromopaque-typealias}

See [extractFromOpaque()](/docs/apis/tree#extractfromopaque-function)<!-- -->.

#### Signature {#extractfromopaque-signature}

```typescript
export declare type ExtractFromOpaque<TOpaque extends BrandedType<any, string>> = TOpaque extends BrandedType<infer ValueType, infer Name> ? isAny<ValueType> extends true ? unknown : Brand<ValueType, Name> : never;
```

### FieldChangeMap {#fieldchangemap-typealias}

#### Signature {#fieldchangemap-signature}

```typescript
export declare type FieldChangeMap = Map<FieldKey, FieldChange>;
```

### FieldChangeset {#fieldchangeset-typealias}

#### Signature {#fieldchangeset-signature}

```typescript
export declare type FieldChangeset = Brand<unknown, "FieldChangeset">;
```

### FieldKey {#fieldkey-typealias}

Either LocalFieldKey or GlobalFieldKey.

To avoid collisions, we can not abstract over local and global field keys using the same format for each (that would make telling them apart impossible). Thus global field keys are using their symbols instead.

#### Signature {#fieldkey-signature}

```typescript
export declare type FieldKey = LocalFieldKey | GlobalFieldKeySymbol;
```

### FieldKindIdentifier {#fieldkindidentifier-typealias}

Identifier for a FieldKind. Refers to an exact stable policy (ex: specific version of a policy), for how to handle (ex: edit and merge edits to) fields marked with this kind. Persisted in documents as part of stored schema.

#### Signature {#fieldkindidentifier-signature}

```typescript
export declare type FieldKindIdentifier = Brand<string, "tree.FieldKindIdentifier">;
```

### ForestLocation {#forestlocation-typealias}

Ways to refer to a node in an IEditableForest.

#### Signature {#forestlocation-signature}

```typescript
export declare type ForestLocation = ITreeSubscriptionCursor | Anchor;
```

### GlobalFieldKey {#globalfieldkey-typealias}

SchemaIdentifier for a "global field", meaning a field which has the same meaning for all usages within the document (not scoped to a specific TreeSchema like LocalFieldKey).

#### Signature {#globalfieldkey-signature}

```typescript
export declare type GlobalFieldKey = Brand<string, "tree.GlobalFieldKey">;
```

### GlobalFieldKeySymbol {#globalfieldkeysymbol-typealias}

Symbol which can be used to lookup a global field. Using a symbol here avoids the need to use the full string version of the key, and avoids the possibility of colliding with local field keys.

Must only be produced using [symbolFromKey()](/docs/apis/tree#symbolfromkey-function)<!-- -->.

#### Signature {#globalfieldkeysymbol-signature}

```typescript
export declare type GlobalFieldKeySymbol = Brand<symbol, "GlobalFieldKeySymbol">;
```

### IdAllocator {#idallocator-typealias}

#### Signature {#idallocator-signature}

```typescript
export declare type IdAllocator = () => ChangesetLocalId;
```

### isAny {#isany-typealias}

Returns a type parameter that is true iff T is any.

#### Signature {#isany-signature}

```typescript
export declare type isAny<T> = boolean extends (T extends {} ? true : false) ? true : false;
```

### JsonCompatible {#jsoncompatible-typealias}

Use for Json compatible data.

Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.

#### Signature {#jsoncompatible-signature}

```typescript
export declare type JsonCompatible = string | number | boolean | null | JsonCompatible[] | JsonCompatibleObject;
```

### JsonCompatibleObject {#jsoncompatibleobject-typealias}

Use for Json object compatible data.

Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.

#### Signature {#jsoncompatibleobject-signature}

```typescript
export declare type JsonCompatibleObject = {
    [P in string]: JsonCompatible;
};
```

### JsonCompatibleReadOnly {#jsoncompatiblereadonly-typealias}

Use for readonly view of Json compatible data.

Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.

#### Signature {#jsoncompatiblereadonly-signature}

```typescript
export declare type JsonCompatibleReadOnly = string | number | boolean | null | readonly JsonCompatibleReadOnly[] | {
    readonly [P in string]: JsonCompatibleReadOnly | undefined;
};
```

### LocalFieldKey {#localfieldkey-typealias}

Key (aka Name or Label) for a field which is scoped to a specific TreeSchema.

#### Signature {#localfieldkey-signature}

```typescript
export declare type LocalFieldKey = Brand<string, "tree.LocalFieldKey">;
```

### NamedTreeSchema {#namedtreeschema-typealias}

#### Signature {#namedtreeschema-signature}

```typescript
export declare type NamedTreeSchema = TreeSchema & Named<TreeSchemaIdentifier>;
```

### NameFromBranded {#namefrombranded-typealias}

Implementation detail of type branding. Should not be used directly outside this file, but shows up as part of branded types so API-Extractor requires it to be exported.

#### Signature {#namefrombranded-signature}

```typescript
export declare type NameFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<any, infer Name> ? Name : never;
```

### NodeChangeComposer {#nodechangecomposer-typealias}

#### Signature {#nodechangecomposer-signature}

```typescript
export declare type NodeChangeComposer = (changes: TaggedChange<NodeChangeset>[]) => NodeChangeset;
```

### NodeChangeDecoder {#nodechangedecoder-typealias}

#### Signature {#nodechangedecoder-signature}

```typescript
export declare type NodeChangeDecoder = (change: JsonCompatibleReadOnly) => NodeChangeset;
```

### NodeChangeEncoder {#nodechangeencoder-typealias}

#### Signature {#nodechangeencoder-signature}

```typescript
export declare type NodeChangeEncoder = (change: NodeChangeset) => JsonCompatibleReadOnly;
```

### NodeChangeInverter {#nodechangeinverter-typealias}

#### Signature {#nodechangeinverter-signature}

```typescript
export declare type NodeChangeInverter = (change: NodeChangeset) => NodeChangeset;
```

### NodeChangeRebaser {#nodechangerebaser-typealias}

#### Signature {#nodechangerebaser-signature}

```typescript
export declare type NodeChangeRebaser = (change: NodeChangeset, baseChange: NodeChangeset) => NodeChangeset;
```

### NodeReviver {#nodereviver-typealias}

#### Signature {#nodereviver-signature}

```typescript
export declare type NodeReviver = (revision: RevisionTag, index: number, count: number) => Delta.ProtoNode[];
```

### Opaque {#opaque-typealias}

Converts a Branded type into an "opaque" handle. This prevents the value from being used directly, but does not fully type erase it (and this its not really fully opaque): The type can be recovered using [extractFromOpaque()](/docs/apis/tree#extractfromopaque-function)<!-- -->, however if we assume only code that produces these "opaque" handles does that conversion, they can function like opaque handles.

Recommenced usage is to use `interface` instead of `type` so tooling (such as tsc and refactoring tools) uses the type name instead of expanding it:

```typescript
export interface MyType extends Opaque<Brand<string, "myPackage.MyType">>{}
```

#### Signature {#opaque-signature}

```typescript
export declare type Opaque<T extends Brand<any, string>> = T extends Brand<infer ValueType, infer Name> ? BrandedType<ValueType, Name> : never;
```

### PrimitiveValue {#primitivevalue-typealias}

#### Signature {#primitivevalue-signature}

```typescript
export declare type PrimitiveValue = string | boolean | number;
```

### RevisionTag {#revisiontag-typealias}

A way to refer to a particular revision within a given `Rebaser` instance.

#### Signature {#revisiontag-signature}

```typescript
export declare type RevisionTag = Brand<number, "rebaser.RevisionTag">;
```

### ToDelta {#todelta-typealias}

The `index` represents the index of the child node in the input context. The `index` should be `undefined` iff the child node does not exist in the input context (e.g., an inserted node).

#### Signature {#todelta-signature}

```typescript
export declare type ToDelta = (child: NodeChangeset, index: number | undefined) => Delta.Modify;
```

### TreeSchemaIdentifier {#treeschemaidentifier-typealias}

SchemaIdentifier for a Tree. Also known as "Definition"

#### Signature {#treeschemaidentifier-signature}

```typescript
export declare type TreeSchemaIdentifier = Brand<string, "tree.TreeSchemaIdentifier">;
```

### TreeType {#treetype-typealias}

#### Signature {#treetype-signature}

```typescript
export declare type TreeType = TreeSchemaIdentifier;
```

### TreeTypeSet {#treetypeset-typealias}

Set of allowed tree types. Providing multiple values here allows polymorphism, tagged union style.

If not specified, types are unconstrained (equivalent to the set containing every TreeSchemaIdentifier defined in the document).

Note that even when unconstrained, children must still be in-schema for their own type.

In the future, this could be extended to allow inlining a TreeSchema here (or some similar structural schema system). For structural types which could go here, there are a few interesting options:

- Allow replacing the whole set with a structural type for terminal / non-tree data, and use this as a replacement for values on the tree nodes.

- Allow expression structural constraints for child trees, for example requiring specific traits (ex: via TreeSchema), instead of by type.

There are two ways this could work:

- Constrain the child nodes based on their shape: this makes schema safe editing difficult because nodes would incur extra editing constraints to prevent them from going out of schema based on their location in such a field.

- Constrain the types allowed based on which types guarantee their data will always meet the constraints.

Care would need to be taken to make sure this is sound for the schema updating mechanisms.

#### Signature {#treetypeset-signature}

```typescript
export declare type TreeTypeSet = ReadonlySet<TreeSchemaIdentifier> | undefined;
```

### UnwrappedEditableField {#unwrappededitablefield-typealias}

Unwrapped field. Non-sequence multiplicities are unwrapped to the child tree or `undefined` if there is none. Sequence multiplicities are handled with [EditableField](/docs/apis/tree/editablefield-interface)<!-- -->. See [UnwrappedEditableTree](/docs/apis/tree#unwrappededitabletree-typealias) for how the children themselves are unwrapped.

#### Signature {#unwrappededitablefield-signature}

```typescript
export declare type UnwrappedEditableField = UnwrappedEditableTree | undefined | EditableField;
```

### UnwrappedEditableTree {#unwrappededitabletree-typealias}

EditableTree, but with these cases of unwrapping: - primitives are unwrapped. See [EditableTreeOrPrimitive](/docs/apis/tree#editabletreeorprimitive-typealias)<!-- -->. - nodes with PrimaryField (see `getPrimaryField`<!-- -->) are unwrapped to [EditableField](/docs/apis/tree/editablefield-interface)<!-- -->s. - fields are unwrapped based on their schema's multiplicity. See [UnwrappedEditableField](/docs/apis/tree#unwrappededitablefield-typealias)<!-- -->.

#### Signature {#unwrappededitabletree-signature}

```typescript
export declare type UnwrappedEditableTree = EditableTreeOrPrimitive | EditableField;
```

### Value {#value-typealias}

Value stored on a node.

#### Signature {#value-signature}

```typescript
export declare type Value = undefined | TreeValue;
```

### ValueChange {#valuechange-typealias}

#### Signature {#valuechange-signature}

```typescript
export declare type ValueChange = {
    revision?: RevisionTag;
    value?: Value;
} | {
    revision?: RevisionTag;
    revert: RevisionTag | undefined;
};
```

### ValueFromBranded {#valuefrombranded-typealias}

Implementation detail of type branding. Should not be used directly outside this file, but shows up as part of branded types so API-Extractor requires it to be exported.

#### Signature {#valuefrombranded-signature}

```typescript
export declare type ValueFromBranded<T extends BrandedType<any, string>> = T extends BrandedType<infer ValueType, string> ? ValueType : never;
```

## Function Details

### brand {#brand-function}

Adds a type [Brand](/docs/apis/tree#brand-typealias) to a value.

Only do this when specifically allowed by the requirements of the type being converted to.

#### Signature {#brand-signature}

```typescript
export declare function brand<T extends Brand<any, string>>(value: T extends BrandedType<infer ValueType, string> ? ValueType : never): T;
```

#### Parameters {#brand-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        value
      </td>
      <td>
        T extends <a href='/docs/apis/tree/brandedtype-class'>BrandedType</a><infer ValueType, string> ? ValueType : never
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#brand-returns}

<b>Return type:</b> T

### brandOpaque {#brandopaque-function}

Adds a type [Brand](/docs/apis/tree#brand-typealias) to a value, returning it as a [Opaque](/docs/apis/tree#opaque-typealias) handle.

Only do this when specifically allowed by the requirements of the type being converted to.

#### Signature {#brandopaque-signature}

```typescript
export declare function brandOpaque<T extends BrandedType<any, string>>(value: isAny<ValueFromBranded<T>> extends true ? never : ValueFromBranded<T>): BrandedType<ValueFromBranded<T>, NameFromBranded<T>>;
```

#### Parameters {#brandopaque-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        value
      </td>
      <td>
        <a href='/docs/apis/tree#isany-typealias'>isAny</a><<a href='/docs/apis/tree#valuefrombranded-typealias'>ValueFromBranded</a><T>> extends true ? never : <a href='/docs/apis/tree#valuefrombranded-typealias'>ValueFromBranded</a><T>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#brandopaque-returns}

<b>Return type:</b> [BrandedType](/docs/apis/tree/brandedtype-class)<!-- -->&lt;[ValueFromBranded](/docs/apis/tree#valuefrombranded-typealias)<!-- -->&lt;T&gt;, [NameFromBranded](/docs/apis/tree#namefrombranded-typealias)<!-- -->&lt;T&gt;&gt;

### buildForest {#buildforest-function}

#### Signature {#buildforest-signature}

```typescript
export declare function buildForest(schema: StoredSchemaRepository, anchors?: AnchorSet): IEditableForest;
```

#### Parameters {#buildforest-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        schema
      </td>
      <td>
      </td>
      <td>
        <a href='/docs/apis/tree/storedschemarepository-interface'>StoredSchemaRepository</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        anchors
      </td>
      <td>
        optional
      </td>
      <td>
        <a href='/docs/apis/tree/anchorset-class'>AnchorSet</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#buildforest-returns}

an implementation of [IEditableForest](/docs/apis/tree/ieditableforest-interface) with no data or schema.

<b>Return type:</b> [IEditableForest](/docs/apis/tree/ieditableforest-interface)

### cursorToJsonObject {#cursortojsonobject-function}

Extract a JS object tree from the contents of the given ITreeCursor. Assumes that ITreeCursor contains only unaugmented JsonTypes.

#### Signature {#cursortojsonobject-signature}

```typescript
export declare function cursorToJsonObject(reader: ITreeCursor): JsonCompatible;
```

#### Parameters {#cursortojsonobject-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        reader
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#cursortojsonobject-returns}

<b>Return type:</b> [JsonCompatible](/docs/apis/tree#jsoncompatible-typealias)

### extractFromOpaque {#extractfromopaque-function}

Converts a [Opaque](/docs/apis/tree#opaque-typealias) handle to the underlying branded type.

It is assumed that only code that produces these "opaque" handles does this conversion, allowing these handles to be considered opaque.

#### Signature {#extractfromopaque-signature}

```typescript
export declare function extractFromOpaque<TOpaque extends BrandedType<any, string>>(value: TOpaque): ExtractFromOpaque<TOpaque>;
```

#### Parameters {#extractfromopaque-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        value
      </td>
      <td>
        TOpaque
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#extractfromopaque-returns}

<b>Return type:</b> [ExtractFromOpaque](/docs/apis/tree#extractfromopaque-typealias)<!-- -->&lt;TOpaque&gt;

### getPrimaryField {#getprimaryfield-function}

#### Signature {#getprimaryfield-signature}

```typescript
export declare function getPrimaryField(schema: TreeSchema): {
    key: LocalFieldKey;
    schema: FieldSchema;
} | undefined;
```

#### Parameters {#getprimaryfield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        schema
      </td>
      <td>
        <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#getprimaryfield-returns}

the key and the schema of the primary field out of the given tree schema.

See note on [EmptyKey](/docs/apis/tree#emptykey-variable) for what is a primary field.

<b>Return type:</b> { key: [LocalFieldKey](/docs/apis/tree#localfieldkey-typealias)<!-- -->; schema: [FieldSchema](/docs/apis/tree/fieldschema-interface)<!-- -->; } \| undefined

### isContextuallyTypedNodeDataObject {#iscontextuallytypednodedataobject-function}

Checks the type of a `ContextuallyTypedNodeData`<!-- -->.

#### Signature {#iscontextuallytypednodedataobject-signature}

```typescript
export declare function isContextuallyTypedNodeDataObject(data: ContextuallyTypedNodeData | undefined): data is ContextuallyTypedNodeDataObject;
```

#### Parameters {#iscontextuallytypednodedataobject-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a> | undefined
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#iscontextuallytypednodedataobject-returns}

<b>Return type:</b> data is [ContextuallyTypedNodeDataObject](/docs/apis/tree/contextuallytypednodedataobject-interface)

### isEditableField {#iseditablefield-function}

Checks the type of an UnwrappedEditableField.

#### Signature {#iseditablefield-signature}

```typescript
export declare function isEditableField(field: UnwrappedEditableField): field is EditableField;
```

#### Parameters {#iseditablefield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        field
      </td>
      <td>
        <a href='/docs/apis/tree#unwrappededitablefield-typealias'>UnwrappedEditableField</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#iseditablefield-returns}

<b>Return type:</b> field is [EditableField](/docs/apis/tree/editablefield-interface)

### isGlobalFieldKey {#isglobalfieldkey-function}

Derives the scope using the type of `key`<!-- -->.

#### Signature {#isglobalfieldkey-signature}

```typescript
export declare function isGlobalFieldKey(key: FieldKey): key is GlobalFieldKeySymbol;
```

#### Parameters {#isglobalfieldkey-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isglobalfieldkey-returns}

<b>Return type:</b> key is [GlobalFieldKeySymbol](/docs/apis/tree#globalfieldkeysymbol-typealias)

### isNeverField {#isneverfield-function}

#### Signature {#isneverfield-signature}

```typescript
export declare function isNeverField(policy: FullSchemaPolicy, originalData: SchemaData, field: FieldSchema): boolean;
```

#### Parameters {#isneverfield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        policy
      </td>
      <td>
        <a href='/docs/apis/tree/fullschemapolicy-interface'>FullSchemaPolicy</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        originalData
      </td>
      <td>
        <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        field
      </td>
      <td>
        <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isneverfield-returns}

<b>Return type:</b> boolean

### isPrimitive {#isprimitive-function}

#### Signature {#isprimitive-signature}

```typescript
export declare function isPrimitive(schema: TreeSchema): boolean;
```

#### Parameters {#isprimitive-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        schema
      </td>
      <td>
        <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isprimitive-returns}

true iff `schema` trees should default to being viewed as just their value when possible.

Note that this may return true for some types which can not be unwrapped to just their value, since EditableTree avoids ever unwrapping primitives that are objects so users checking for primitives by type won't be broken. Checking for this object case is done elsewhere.

<b>Return type:</b> boolean

### isPrimitiveValue {#isprimitivevalue-function}

#### Signature {#isprimitivevalue-signature}

```typescript
export declare function isPrimitiveValue(nodeValue: Value): nodeValue is PrimitiveValue;
```

#### Parameters {#isprimitivevalue-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        nodeValue
      </td>
      <td>
        <a href='/docs/apis/tree#value-typealias'>Value</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isprimitivevalue-returns}

<b>Return type:</b> nodeValue is [PrimitiveValue](/docs/apis/tree#primitivevalue-typealias)

### isUnwrappedNode {#isunwrappednode-function}

Checks the type of an UnwrappedEditableField.

#### Signature {#isunwrappednode-signature}

```typescript
export declare function isUnwrappedNode(field: UnwrappedEditableField): field is EditableTree;
```

#### Parameters {#isunwrappednode-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        field
      </td>
      <td>
        <a href='/docs/apis/tree#unwrappededitablefield-typealias'>UnwrappedEditableField</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isunwrappednode-returns}

<b>Return type:</b> field is [EditableTree](/docs/apis/tree/editabletree-interface)

### isWritableArrayLike {#iswritablearraylike-function}

Checks the type of a `ContextuallyTypedNodeData`<!-- -->.

#### Signature {#iswritablearraylike-signature}

```typescript
export declare function isWritableArrayLike(data: ContextuallyTypedNodeData | undefined): data is MarkedArrayLike<ContextuallyTypedNodeData>;
```

#### Parameters {#iswritablearraylike-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a> | undefined
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#iswritablearraylike-returns}

<b>Return type:</b> data is [MarkedArrayLike](/docs/apis/tree/markedarraylike-interface)<!-- -->&lt;[ContextuallyTypedNodeData](/docs/apis/tree#contextuallytypednodedata-typealias)<!-- -->&gt;

### jsonableTreeFromCursor {#jsonabletreefromcursor-function}

Extract a JsonableTree from the contents of the given ITreeCursor's current node.

#### Signature {#jsonabletreefromcursor-signature}

```typescript
export declare function jsonableTreeFromCursor(cursor: ITreeCursor): JsonableTree;
```

#### Parameters {#jsonabletreefromcursor-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        cursor
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#jsonabletreefromcursor-returns}

<b>Return type:</b> [JsonableTree](/docs/apis/tree/jsonabletree-interface)

### keyFromSymbol {#keyfromsymbol-function}

#### Signature {#keyfromsymbol-signature}

```typescript
export declare function keyFromSymbol(key: GlobalFieldKeySymbol): GlobalFieldKey;
```

#### Parameters {#keyfromsymbol-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#keyfromsymbol-returns}

the original [GlobalFieldKey](/docs/apis/tree#globalfieldkey-typealias) for the symbol.

<b>Return type:</b> [GlobalFieldKey](/docs/apis/tree#globalfieldkey-typealias)

### recordDependency {#recorddependency-function}

Ensures this context's computation is a dependant to dependee (adding it if needed). Ensures this context's computation has dependee as a dependee (adding it if needed).

#### Signature {#recorddependency-signature}

```typescript
export declare function recordDependency(dependent: ObservingDependent | undefined, dependee: Dependee): void;
```

#### Parameters {#recorddependency-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        dependent
      </td>
      <td>
        <a href='/docs/apis/tree/observingdependent-interface'>ObservingDependent</a> | undefined
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        dependee
      </td>
      <td>
        <a href='/docs/apis/tree/dependee-interface'>Dependee</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

### singleJsonCursor {#singlejsoncursor-function}

Used to read a Jsonable tree for testing and benchmarking.

#### Signature {#singlejsoncursor-signature}

```typescript
export declare function singleJsonCursor(root: JsonCompatible): ITreeCursorSynchronous;
```

#### Parameters {#singlejsoncursor-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        root
      </td>
      <td>
        <a href='/docs/apis/tree#jsoncompatible-typealias'>JsonCompatible</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#singlejsoncursor-returns}

an [ITreeCursorSynchronous](/docs/apis/tree/itreecursorsynchronous-interface) for a single [JsonCompatible](/docs/apis/tree#jsoncompatible-typealias)<!-- -->.

<b>Return type:</b> [ITreeCursorSynchronous](/docs/apis/tree/itreecursorsynchronous-interface)

### symbolFromKey {#symbolfromkey-function}

#### Signature {#symbolfromkey-signature}

```typescript
export declare function symbolFromKey(key: GlobalFieldKey): GlobalFieldKeySymbol;
```

#### Parameters {#symbolfromkey-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#globalfieldkey-typealias'>GlobalFieldKey</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#symbolfromkey-returns}

a symbol to use for `key`<!-- -->.

<b>Return type:</b> [GlobalFieldKeySymbol](/docs/apis/tree#globalfieldkeysymbol-typealias)

### symbolIsFieldKey {#symbolisfieldkey-function}

#### Signature {#symbolisfieldkey-signature}

```typescript
export declare function symbolIsFieldKey(key: symbol): key is GlobalFieldKeySymbol;
```

#### Parameters {#symbolisfieldkey-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        symbol
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#symbolisfieldkey-returns}

true iff `key` is a [GlobalFieldKeySymbol](/docs/apis/tree#globalfieldkeysymbol-typealias)<!-- -->.

<b>Return type:</b> key is [GlobalFieldKeySymbol](/docs/apis/tree#globalfieldkeysymbol-typealias)

## Variable Details

### createField {#createfield-variable}

A symbol to get the function, which creates a new field of [EditableTree](/docs/apis/tree/editabletree-interface)<!-- -->, in contexts where string keys are already in use for fields.

#### Signature {#createfield-signature}

```typescript
createField: unique symbol
```

### defaultSchemaPolicy {#defaultschemapolicy-variable}

FullSchemaPolicy the default field kinds, empty default fields and neverTree for the default tree schema.

This requires new node types to have explicit stored schema to exist in documents, and allows adding new global fields along with their schema at any point.

#### Signature {#defaultschemapolicy-signature}

```typescript
defaultSchemaPolicy: FullSchemaPolicy
```

### emptyField {#emptyfield-variable}

FieldSchema which is impossible to put anything in.

#### Signature {#emptyfield-signature}

```typescript
emptyField: import("../core").FieldSchema
```

### EmptyKey {#emptykey-variable}

The empty key ("") is used for unnamed relationships, such as the indexer of an explicit array node.

This key is a hint that this field is the primary function of the node, and in some abstractions the APIs for this field should be inlined onto the node.

TODO: This has to be a LocalFieldKey since different nodes will have different FieldSchema for it. This makes it prone to collisions and suggests that this intention may be better conveyed by metadata on the TreeViewSchema.

#### Signature {#emptykey-signature}

```typescript
EmptyKey: LocalFieldKey
```

### getField {#getfield-variable}

A symbol to get the function, which returns the field of [EditableTree](/docs/apis/tree/editabletree-interface) without unwrapping, in contexts where string keys are already in use for fields.

#### Signature {#getfield-signature}

```typescript
getField: unique symbol
```

### indexSymbol {#indexsymbol-variable}

A symbol to get the index of [EditableTree](/docs/apis/tree/editabletree-interface) within its parent field in contexts where string keys are already in use for fields.

#### Signature {#indexsymbol-signature}

```typescript
indexSymbol: unique symbol
```

### jsonArray {#jsonarray-variable}

#### Signature {#jsonarray-signature}

```typescript
jsonArray: NamedTreeSchema
```

### jsonBoolean {#jsonboolean-variable}

#### Signature {#jsonboolean-signature}

```typescript
jsonBoolean: NamedTreeSchema
```

### jsonNull {#jsonnull-variable}

#### Signature {#jsonnull-signature}

```typescript
jsonNull: NamedTreeSchema
```

### jsonNumber {#jsonnumber-variable}

#### Signature {#jsonnumber-signature}

```typescript
jsonNumber: NamedTreeSchema
```

### jsonObject {#jsonobject-variable}

#### Signature {#jsonobject-signature}

```typescript
jsonObject: NamedTreeSchema
```

### jsonSchemaData {#jsonschemadata-variable}

#### Signature {#jsonschemadata-signature}

```typescript
jsonSchemaData: SchemaData
```

### jsonString {#jsonstring-variable}

#### Signature {#jsonstring-signature}

```typescript
jsonString: NamedTreeSchema
```

### neverTree {#nevertree-variable}

TreeSchema which is impossible for any data to be in schema with.

#### Signature {#nevertree-signature}

```typescript
neverTree: TreeSchema
```

### proxyTargetSymbol {#proxytargetsymbol-variable}

A symbol for extracting target from [EditableTree](/docs/apis/tree/editabletree-interface) proxies. Useful for debugging and testing, but not part of the public API.

#### Signature {#proxytargetsymbol-signature}

```typescript
proxyTargetSymbol: unique symbol
```

### replaceField {#replacefield-variable}

A symbol to get the function, which replaces a field of [EditableTree](/docs/apis/tree/editabletree-interface)<!-- -->, in contexts where string keys are already in use for fields.

#### Signature {#replacefield-signature}

```typescript
replaceField: unique symbol
```

### rootFieldKey {#rootfieldkey-variable}

GlobalFieldKey to use for the root of documents. TODO: if we do want to standardize on a single value for this, it likely should be namespaced or a UUID to avoid risk of collisions.

#### Signature {#rootfieldkey-signature}

```typescript
rootFieldKey: GlobalFieldKey
```

### typeNameSymbol {#typenamesymbol-variable}

A symbol to get the type name of [EditableTree](/docs/apis/tree/editabletree-interface) in contexts where string keys are already in use for fields.

#### Signature {#typenamesymbol-signature}

```typescript
typeNameSymbol: unique symbol
```

### typeSymbol {#typesymbol-variable}

A symbol to get the type of [EditableTree](/docs/apis/tree/editabletree-interface) in contexts where string keys are already in use for fields.

#### Signature {#typesymbol-signature}

```typescript
typeSymbol: unique symbol
```

### valueSymbol {#valuesymbol-variable}

A symbol to get and set the value of [EditableTree](/docs/apis/tree/editabletree-interface) in contexts where string keys are already in use for fields.

Setting the value using the simple assignment operator (`=`<!-- -->) is only supported for [PrimitiveValue](/docs/apis/tree#primitivevalue-typealias)<!-- -->s. Concurrently setting the value will follow the "last-write-wins" semantics.

#### Signature {#valuesymbol-signature}

```typescript
valueSymbol: unique symbol
```