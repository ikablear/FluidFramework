{
"title": "@fluid-internal/tree Package",
"kind": "Package",
"members": {
"Class": {
"AdaptedViewSchema": "/docs/apis/tree/adaptedviewschema-class",
"AnchorSet": "/docs/apis/tree/anchorset-class",
"BrandedType": "/docs/apis/tree/brandedtype-class",
"ChangeEncoder": "/docs/apis/tree/changeencoder-class",
"DefaultChangeFamily": "/docs/apis/tree/defaultchangefamily-class",
"DefaultEditBuilder": "/docs/apis/tree/defaulteditbuilder-class",
"DisposingDependee": "/docs/apis/tree/disposingdependee-class",
"EditManager": "/docs/apis/tree/editmanager-class",
"EditManagerIndex": "/docs/apis/tree/editmanagerindex-class",
"FieldKind": "/docs/apis/tree/fieldkind-class",
"ForestIndex": "/docs/apis/tree/forestindex-class",
"ForestRepairDataStore": "/docs/apis/tree/forestrepairdatastore-class",
"InMemoryStoredSchemaRepository": "/docs/apis/tree/inmemorystoredschemarepository-class",
"InvalidationToken": "/docs/apis/tree/invalidationtoken-class",
"ModularChangeFamily": "/docs/apis/tree/modularchangefamily-class",
"ModularEditBuilder": "/docs/apis/tree/modulareditbuilder-class",
"ProgressiveEditBuilderBase": "/docs/apis/tree/progressiveeditbuilderbase-class",
"Rebaser": "/docs/apis/tree/rebaser-class",
"SchemaEditor": "/docs/apis/tree/schemaeditor-class",
"SchemaIndex": "/docs/apis/tree/schemaindex-class",
"SharedTreeCore": "/docs/apis/tree/sharedtreecore-class",
"SharedTreeFactory": "/docs/apis/tree/sharedtreefactory-class",
"SimpleDependee": "/docs/apis/tree/simpledependee-class",
"SimpleObservingDependent": "/docs/apis/tree/simpleobservingdependent-class",
"SparseNode": "/docs/apis/tree/sparsenode-class",
"ViewSchemaData": "/docs/apis/tree/viewschemadata-class"
},
"Interface": {
"Adapters": "/docs/apis/tree/adapters-interface",
"AnchorLocator": "/docs/apis/tree/anchorlocator-interface",
"Branch": "/docs/apis/tree/branch-interface",
"ChangeFamily": "/docs/apis/tree/changefamily-interface",
"ChangeRebaser": "/docs/apis/tree/changerebaser-interface",
"Checkout": "/docs/apis/tree/checkout-interface",
"ChildLocation": "/docs/apis/tree/childlocation-interface",
"Commit": "/docs/apis/tree/commit-interface",
"CommitEncoder": "/docs/apis/tree/commitencoder-interface",
"ContextuallyTypedNodeDataObject": "/docs/apis/tree/contextuallytypednodedataobject-interface",
"Contravariant": "/docs/apis/tree/contravariant-interface",
"Covariant": "/docs/apis/tree/covariant-interface",
"CursorAdapter": "/docs/apis/tree/cursoradapter-interface",
"CursorWithNode": "/docs/apis/tree/cursorwithnode-interface",
"DeltaVisitor": "/docs/apis/tree/deltavisitor-interface",
"Dependee": "/docs/apis/tree/dependee-interface",
"Dependent": "/docs/apis/tree/dependent-interface",
"DetachedField": "/docs/apis/tree/detachedfield-interface",
"EditableField": "/docs/apis/tree/editablefield-interface",
"EditableTree": "/docs/apis/tree/editabletree-interface",
"EditableTreeContext": "/docs/apis/tree/editabletreecontext-interface",
"Exception": "/docs/apis/tree/exception-interface",
"FieldAdapter": "/docs/apis/tree/fieldadapter-interface",
"FieldAnchor": "/docs/apis/tree/fieldanchor-interface",
"FieldChange": "/docs/apis/tree/fieldchange-interface",
"FieldChangeEncoder": "/docs/apis/tree/fieldchangeencoder-interface",
"FieldChangeHandler": "/docs/apis/tree/fieldchangehandler-interface",
"FieldChangeRebaser": "/docs/apis/tree/fieldchangerebaser-interface",
"FieldEditor": "/docs/apis/tree/fieldeditor-interface",
"FieldLocation": "/docs/apis/tree/fieldlocation-interface",
"FieldMapObject": "/docs/apis/tree/fieldmapobject-interface",
"FieldSchema": "/docs/apis/tree/fieldschema-interface",
"FieldUpPath": "/docs/apis/tree/fielduppath-interface",
"FinalChange": "/docs/apis/tree/finalchange-interface",
"FullSchemaPolicy": "/docs/apis/tree/fullschemapolicy-interface",
"GenericChange": "/docs/apis/tree/genericchange-interface",
"GenericFieldsNode": "/docs/apis/tree/genericfieldsnode-interface",
"GenericTreeNode": "/docs/apis/tree/generictreenode-interface",
"ICachedValue": "/docs/apis/tree/icachedvalue-interface",
"ICheckout": "/docs/apis/tree/icheckout-interface",
"IDefaultEditBuilder": "/docs/apis/tree/idefaulteditbuilder-interface",
"IEditableForest": "/docs/apis/tree/ieditableforest-interface",
"IForestSubscription": "/docs/apis/tree/iforestsubscription-interface",
"Index": "/docs/apis/tree/index-interface",
"Invariant": "/docs/apis/tree/invariant-interface",
"ISharedTree": "/docs/apis/tree/isharedtree-interface",
"ISharedTreeCoreEvents": "/docs/apis/tree/isharedtreecoreevents-interface",
"ITreeCursor": "/docs/apis/tree/itreecursor-interface",
"ITreeCursorSynchronous": "/docs/apis/tree/itreecursorsynchronous-interface",
"ITreeSubscriptionCursor": "/docs/apis/tree/itreesubscriptioncursor-interface",
"JsonableTree": "/docs/apis/tree/jsonabletree-interface",
"MakeNominal": "/docs/apis/tree/makenominal-interface",
"MapTree": "/docs/apis/tree/maptree-interface",
"MarkedArrayLike": "/docs/apis/tree/markedarraylike-interface",
"ModularChangeset": "/docs/apis/tree/modularchangeset-interface",
"MutableSchemaData": "/docs/apis/tree/mutableschemadata-interface",
"MutableSummaryData": "/docs/apis/tree/mutablesummarydata-interface",
"Named": "/docs/apis/tree/named-interface",
"NamedComputation": "/docs/apis/tree/namedcomputation-interface",
"NodeChangeset": "/docs/apis/tree/nodechangeset-interface",
"NodeData": "/docs/apis/tree/nodedata-interface",
"ObservingContext": "/docs/apis/tree/observingcontext-interface",
"ObservingDependent": "/docs/apis/tree/observingdependent-interface",
"OptionalFieldEditBuilder": "/docs/apis/tree/optionalfieldeditbuilder-interface",
"OutputType": "/docs/apis/tree/outputtype-interface",
"ProgressiveEditBuilder": "/docs/apis/tree/progressiveeditbuilder-interface",
"ReadonlyRepairDataStore": "/docs/apis/tree/readonlyrepairdatastore-interface",
"ReadonlySummaryData": "/docs/apis/tree/readonlysummarydata-interface",
"RepairDataStore": "/docs/apis/tree/repairdatastore-interface",
"RootField": "/docs/apis/tree/rootfield-interface",
"SchemaData": "/docs/apis/tree/schemadata-interface",
"SchemaDataAndPolicy": "/docs/apis/tree/schemadataandpolicy-interface",
"SchemaOp": "/docs/apis/tree/schemaop-interface",
"SchemaPolicy": "/docs/apis/tree/schemapolicy-interface",
"SequenceFieldEditBuilder": "/docs/apis/tree/sequencefieldeditbuilder-interface",
"StoredSchemaRepository": "/docs/apis/tree/storedschemarepository-interface",
"SummaryElement": "/docs/apis/tree/summaryelement-interface",
"TaggedChange": "/docs/apis/tree/taggedchange-interface",
"TreeAdapter": "/docs/apis/tree/treeadapter-interface",
"TreeLocation": "/docs/apis/tree/treelocation-interface",
"TreeSchema": "/docs/apis/tree/treeschema-interface",
"TreeSchemaBuilder": "/docs/apis/tree/treeschemabuilder-interface",
"TreeValue": "/docs/apis/tree/treevalue-interface",
"UpPath": "/docs/apis/tree/uppath-interface",
"ValueFieldEditBuilder": "/docs/apis/tree/valuefieldeditbuilder-interface",
"Violation": "/docs/apis/tree/violation-interface"
},
"Variable": {
"afterChangeToken": "/docs/apis/tree#afterchangetoken-variable",
"createField": "/docs/apis/tree#createfield-variable",
"defaultChangeFamily": "/docs/apis/tree#defaultchangefamily-variable",
"defaultSchemaPolicy": "/docs/apis/tree#defaultschemapolicy-variable",
"dummyRepairDataStore": "/docs/apis/tree#dummyrepairdatastore-variable",
"emptyField": "/docs/apis/tree#emptyfield-variable",
"EmptyKey": "/docs/apis/tree#emptykey-variable",
"emptyMap": "/docs/apis/tree#emptymap-variable",
"emptySet": "/docs/apis/tree#emptyset-variable",
"genericFieldKind": "/docs/apis/tree#genericfieldkind-variable",
"getField": "/docs/apis/tree#getfield-variable",
"indexSymbol": "/docs/apis/tree#indexsymbol-variable",
"jsonArray": "/docs/apis/tree#jsonarray-variable",
"jsonBoolean": "/docs/apis/tree#jsonboolean-variable",
"jsonNull": "/docs/apis/tree#jsonnull-variable",
"jsonNumber": "/docs/apis/tree#jsonnumber-variable",
"jsonObject": "/docs/apis/tree#jsonobject-variable",
"jsonRoot": "/docs/apis/tree#jsonroot-variable",
"jsonSchemaData": "/docs/apis/tree#jsonschemadata-variable",
"jsonString": "/docs/apis/tree#jsonstring-variable",
"neverField": "/docs/apis/tree#neverfield-variable",
"neverTree": "/docs/apis/tree#nevertree-variable",
"noFailure": "/docs/apis/tree#nofailure-variable",
"proxyTargetSymbol": "/docs/apis/tree#proxytargetsymbol-variable",
"replaceField": "/docs/apis/tree#replacefield-variable",
"rootField": "/docs/apis/tree#rootfield-variable",
"rootFieldKey": "/docs/apis/tree#rootfieldkey-variable",
"rootFieldKeySymbol": "/docs/apis/tree#rootfieldkeysymbol-variable",
"typeNameSymbol": "/docs/apis/tree#typenamesymbol-variable",
"typeSymbol": "/docs/apis/tree#typesymbol-variable",
"valueSymbol": "/docs/apis/tree#valuesymbol-variable"
},
"Function": {
"allowsRepoSuperset": "/docs/apis/tree#allowsreposuperset-function",
"applyModifyToTree": "/docs/apis/tree#applymodifytotree-function",
"buildForest": "/docs/apis/tree#buildforest-function",
"cachedValue": "/docs/apis/tree#cachedvalue-function",
"clonePath": "/docs/apis/tree#clonepath_1-function",
"commitEncoderFromChangeEncoder": "/docs/apis/tree#commitencoderfromchangeencoder-function",
"compareFieldUpPaths": "/docs/apis/tree#comparefielduppaths-function",
"compareUpPaths": "/docs/apis/tree#compareuppaths-function",
"cursorToJsonObject": "/docs/apis/tree#cursortojsonobject-function",
"detachedFieldAsKey": "/docs/apis/tree#detachedfieldaskey-function",
"encodeSummary": "/docs/apis/tree#encodesummary-function",
"extractFromOpaque": "/docs/apis/tree#extractfromopaque-function",
"fieldSchema": "/docs/apis/tree#fieldschema-function",
"forEachField": "/docs/apis/tree#foreachfield-function",
"forEachNode": "/docs/apis/tree#foreachnode-function",
"genericTreeDeleteIfEmpty": "/docs/apis/tree#generictreedeleteifempty-function",
"genericTreeKeys": "/docs/apis/tree#generictreekeys-function",
"getDepth": "/docs/apis/tree#getdepth-function",
"getDescendant": "/docs/apis/tree#getdescendant-function",
"getEditableTreeContext": "/docs/apis/tree#geteditabletreecontext-function",
"getGenericTreeField": "/docs/apis/tree#getgenerictreefield-function",
"getMapTreeField": "/docs/apis/tree#getmaptreefield-function",
"getPrimaryField": "/docs/apis/tree#getprimaryfield-function",
"getSchemaString": "/docs/apis/tree#getschemastring-function",
"initializeForest": "/docs/apis/tree#initializeforest-function",
"isContextuallyTypedNodeDataObject": "/docs/apis/tree#iscontextuallytypednodedataobject-function",
"isEditableField": "/docs/apis/tree#iseditablefield-function",
"isFieldLocation": "/docs/apis/tree#isfieldlocation-function",
"isGlobalFieldKey": "/docs/apis/tree#isglobalfieldkey-function",
"isLocalKey": "/docs/apis/tree#islocalkey-function",
"isNeverField": "/docs/apis/tree#isneverfield-function",
"isPrimitive": "/docs/apis/tree#isprimitive-function",
"isPrimitiveValue": "/docs/apis/tree#isprimitivevalue-function",
"isUnwrappedNode": "/docs/apis/tree#isunwrappednode-function",
"isWritableArrayLike": "/docs/apis/tree#iswritablearraylike-function",
"jsonableTreeFromCursor": "/docs/apis/tree#jsonabletreefromcursor-function",
"keyAsDetachedField": "/docs/apis/tree#keyasdetachedfield-function",
"keyFromSymbol": "/docs/apis/tree#keyfromsymbol-function",
"loadSummary": "/docs/apis/tree#loadsummary-function",
"lookupGlobalFieldSchema": "/docs/apis/tree#lookupglobalfieldschema-function",
"lookupTreeSchema": "/docs/apis/tree#lookuptreeschema-function",
"makeAnonChange": "/docs/apis/tree#makeanonchange-function",
"mapCursorField": "/docs/apis/tree#mapcursorfield-function",
"mapCursorFields": "/docs/apis/tree#mapcursorfields-function",
"mapFieldMarks": "/docs/apis/tree#mapfieldmarks-function",
"mapFromNamed": "/docs/apis/tree#mapfromnamed-function",
"mapMark": "/docs/apis/tree#mapmark-function",
"mapMarkList": "/docs/apis/tree#mapmarklist-function",
"mapTreeFromCursor": "/docs/apis/tree#maptreefromcursor-function",
"moveToDetachedField": "/docs/apis/tree#movetodetachedfield-function",
"namedTreeSchema": "/docs/apis/tree#namedtreeschema-function",
"recordDependency": "/docs/apis/tree#recorddependency-function",
"runSynchronousTransaction": "/docs/apis/tree#runsynchronoustransaction-function",
"schemaDataIsEmpty": "/docs/apis/tree#schemadataisempty-function",
"scopeFromKey": "/docs/apis/tree#scopefromkey-function",
"setGenericTreeField": "/docs/apis/tree#setgenerictreefield-function",
"singleJsonCursor": "/docs/apis/tree#singlejsoncursor-function",
"singleMapTreeCursor": "/docs/apis/tree#singlemaptreecursor-function",
"singleStackTreeCursor": "/docs/apis/tree#singlestacktreecursor-function",
"singleTextCursor": "/docs/apis/tree#singletextcursor-function",
"symbolFromKey": "/docs/apis/tree#symbolfromkey-function",
"symbolIsFieldKey": "/docs/apis/tree#symbolisfieldkey-function",
"tagChange": "/docs/apis/tree#tagchange-function",
"tagInverse": "/docs/apis/tree#taginverse-function",
"treeSchema": "/docs/apis/tree#treeschema-function",
"verifyChangeRebaser": "/docs/apis/tree#verifychangerebaser-function",
"visitDelta": "/docs/apis/tree#visitdelta-function"
},
"TypeAlias": {
"Anchor": "/docs/apis/tree#anchor-typealias",
"Brand": "/docs/apis/tree#brand-typealias",
"ChangesetFromChangeRebaser": "/docs/apis/tree#changesetfromchangerebaser-typealias",
"ChangesetLocalId": "/docs/apis/tree#changesetlocalid-typealias",
"ChildCollection": "/docs/apis/tree#childcollection-typealias",
"ContextuallyTypedNodeData": "/docs/apis/tree#contextuallytypednodedata-typealias",
"DefaultChangeset": "/docs/apis/tree#defaultchangeset-typealias",
"EditableTreeOrPrimitive": "/docs/apis/tree#editabletreeorprimitive-typealias",
"ExtractFromOpaque": "/docs/apis/tree#extractfromopaque-typealias",
"Failure": "/docs/apis/tree#failure-typealias",
"FieldChangeMap": "/docs/apis/tree#fieldchangemap-typealias",
"FieldChangeset": "/docs/apis/tree#fieldchangeset-typealias",
"FieldKey": "/docs/apis/tree#fieldkey-typealias",
"FieldKindIdentifier": "/docs/apis/tree#fieldkindidentifier-typealias",
"ForestLocation": "/docs/apis/tree#forestlocation-typealias",
"GenericChangeset": "/docs/apis/tree#genericchangeset-typealias",
"GlobalFieldKey": "/docs/apis/tree#globalfieldkey-typealias",
"GlobalFieldKeySymbol": "/docs/apis/tree#globalfieldkeysymbol-typealias",
"IdAllocator": "/docs/apis/tree#idallocator-typealias",
"isAny": "/docs/apis/tree#isany-typealias",
"JsonCompatible": "/docs/apis/tree#jsoncompatible-typealias",
"JsonCompatibleObject": "/docs/apis/tree#jsoncompatibleobject-typealias",
"JsonCompatibleReadOnly": "/docs/apis/tree#jsoncompatiblereadonly-typealias",
"LocalFieldKey": "/docs/apis/tree#localfieldkey-typealias",
"NamedFieldSchema": "/docs/apis/tree#namedfieldschema-typealias",
"NamedTreeSchema": "/docs/apis/tree#namedtreeschema-typealias",
"NodeChangeComposer": "/docs/apis/tree#nodechangecomposer-typealias",
"NodeChangeDecoder": "/docs/apis/tree#nodechangedecoder-typealias",
"NodeChangeEncoder": "/docs/apis/tree#nodechangeencoder-typealias",
"NodeChangeInverter": "/docs/apis/tree#nodechangeinverter-typealias",
"NodeChangeRebaser": "/docs/apis/tree#nodechangerebaser-typealias",
"NodeReviver": "/docs/apis/tree#nodereviver-typealias",
"Opaque": "/docs/apis/tree#opaque-typealias",
"PrimitiveValue": "/docs/apis/tree#primitivevalue-typealias",
"RecursiveReadonly": "/docs/apis/tree#recursivereadonly-typealias",
"RevisionTag": "/docs/apis/tree#revisiontag-typealias",
"SeqNumber": "/docs/apis/tree#seqnumber-typealias",
"SessionId": "/docs/apis/tree#sessionid-typealias",
"SummaryElementParser": "/docs/apis/tree#summaryelementparser-typealias",
"SummaryElementStringifier": "/docs/apis/tree#summaryelementstringifier-typealias",
"ToDelta": "/docs/apis/tree#todelta-typealias",
"TreeSchemaIdentifier": "/docs/apis/tree#treeschemaidentifier-typealias",
"TreeType": "/docs/apis/tree#treetype-typealias",
"TreeTypeSet": "/docs/apis/tree#treetypeset-typealias",
"UnwrappedEditableField": "/docs/apis/tree#unwrappededitablefield-typealias",
"UnwrappedEditableTree": "/docs/apis/tree#unwrappededitabletree-typealias",
"Value": "/docs/apis/tree#value-typealias",
"ValueChange": "/docs/apis/tree#valuechange-typealias"
},
"Enum": {
"Compatibility": "/docs/apis/tree#compatibility-enum",
"CursorLocationType": "/docs/apis/tree#cursorlocationtype-enum",
"FieldScope": "/docs/apis/tree#fieldscope-enum",
"FinalChangeStatus": "/docs/apis/tree#finalchangestatus-enum",
"ITreeSubscriptionCursorState": "/docs/apis/tree#itreesubscriptioncursorstate-enum",
"Multiplicity": "/docs/apis/tree#multiplicity-enum",
"TransactionResult": "/docs/apis/tree#transactionresult-enum",
"TreeNavigationResult": "/docs/apis/tree#treenavigationresult-enum",
"ValueSchema": "/docs/apis/tree#valueschema-enum"
},
"Namespace": {
"Delta": "/docs/apis/tree/delta-namespace",
"FieldKinds": "/docs/apis/tree/fieldkinds-namespace",
"SequenceField": "/docs/apis/tree/sequencefield-namespace"
}
},
"package": "@fluid-internal/tree",
"unscopedPackageName": "tree"
}

[//]: # "Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter."

[Packages](/docs/apis/) &gt; [@fluid-internal/tree](/docs/apis/tree)

## Interfaces

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Interface
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/adapters-interface'>Adapters</a>
      </td>
      <td>
        <p>Minimal selection of adapters (nothing for general out of schema, field level adjustments etc.). Would be used with schematize and have actual conversion/update functionality.</p><p>TODO: Support more kinds of adapters TODO: support efficient lookup of adapters</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/anchorlocator-interface'>AnchorLocator</a>
      </td>
      <td>
        Maps anchors (which must be ones this locator knows about) to paths.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/branch-interface'>Branch</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/changefamily-interface'>ChangeFamily</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/changerebaser-interface'>ChangeRebaser</a>
      </td>
      <td>
        <p>Rebasing logic for a particular kind of change.</p><p>This interface is used to provide rebase policy to <code>Rebaser</code>.</p><p>The implementation must ensure TChangeset forms a [group](https://en.wikipedia.org/wiki/Group_(mathematics)) where: - <code>compose([])</code> is the identity element. - associativity is defined as <code>compose([...a, ...b])</code> is equal to <code>compose([compose(a), compose(b)])</code> for all <code>a</code> and <code>b</code>. - <code>inverse(a)</code> gives the inverse element of <code>a</code>.</p><p>In these requirements the definition of equality is up to the implementer, but it is required that any two changes which are considered equal: - have the same impact when applied to any tree. - can be substituted for each-other in all methods on this interface and produce equal (by this same definition) results.</p><p>For the sake of testability, implementations will likely want to have a concrete equality implementation.</p><p>This API uses <code>compose</code> on arrays instead of an explicit identity element and associative binary operator to allow the implementation more room for optimization, but should otherwise be equivalent to the identity element and binary operator group approach.</p><p>TODO: Be more specific about the above requirements. For example, would something that is close to forming a group but has precision issues (ex: the floating point numbers and addition) be ok? Would this cause decoherence (and thus be absolutely not ok), or just minor semantic precision issues, which could be tolerated. For now assume that such issues are not ok.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/checkout-interface'>Checkout</a>
      </td>
      <td>
        The interface a checkout has to implement for a transaction to be able to be applied to it.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/childlocation-interface'>ChildLocation</a>
      </td>
      <td>
        Location of a tree relative to is parent container (which can be a tree or forest).
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/commit-interface'>Commit</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/commitencoder-interface'>CommitEncoder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/contextuallytypednodedataobject-interface'>ContextuallyTypedNodeDataObject</a>
      </td>
      <td>
        Object case of <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/contravariant-interface'>Contravariant</a>
      </td>
      <td>
        Constrain generic type parameters to Contravariant.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/covariant-interface'>Covariant</a>
      </td>
      <td>
        Constrain generic type parameters to Covariant.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/cursoradapter-interface'>CursorAdapter</a>
      </td>
      <td>
        Provides functionality to allow a <a href='/docs/apis/tree#singlestacktreecursor-function'>singleStackTreeCursor()</a> to implement a cursor.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/cursorwithnode-interface'>CursorWithNode</a>
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursorsynchronous-interface'>ITreeCursorSynchronous</a> that can return the underlying node objects.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/deltavisitor-interface'>DeltaVisitor</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/dependee-interface'>Dependee</a>
      </td>
      <td>
        <p>Interface for object which can change and invalidate <a href='/docs/apis/tree/dependent-interface'>Dependent</a>s when changing. Tracks a set of <code>Dependent</code>s on which <a href='/docs/apis/tree/dependent-interface#markinvalid-methodsignature'>Dependent.markInvalid()</a> will be called when the output of this changes.</p><p>Dependencies are only used for invalidation, so there is no need to make a <code>Dependee</code> when the source data is immutable.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/dependent-interface'>Dependent</a>
      </td>
      <td>
        <p>Object that can depend on <a href='/docs/apis/tree/dependee-interface'>Dependee</a>s.</p><p>Provides a callback (<a href='/docs/apis/tree/dependent-interface#markinvalid-methodsignature'>Dependent.markInvalid()</a>) for the <code>Dependee</code> to invoke when it is invalidated.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/detachedfield-interface'>DetachedField</a>
      </td>
      <td>
        <p>A root in the forest.</p><p>The range is a "container" like a field: any additional content inserted before or after contents of this range will be included in the range. This also means that moving the content from this range elsewhere will leave this range valid, but empty.</p><p>DetachedFields are not valid to use as across edits: they are only valid within the edit in which they were created.</p><p>In some APIs DetachedFields are used as LocalFieldKeys on a special implicit root node to simplify the APIs and implementation.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>
      </td>
      <td>
        <p>A field of an <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> as an array-like sequence of unwrapped nodes (see <a href='/docs/apis/tree#unwrappededitabletree-typealias'>UnwrappedEditableTree</a>).</p><p>The number of nodes depends on a field's multiplicity. When iterating, the nodes are read at once. Use index access to read the nodes "lazily". Use <code>getNode</code> to get a node without unwrapping.</p><p>It is possible to create/replace a node or to set its value by using the simple assignment operator (<code>=</code>) and providing an input data as a <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a>. See <code>EditableTreeContext.unwrappedRoot</code> for more details, as it works the same way for all children of the tree starting from its root.</p><p>It is forbidden to delete the node using the <code>delete</code> operator, use the <code>deleteNodes()</code> method instead.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a>
      </td>
      <td>
        <p>A tree which can be traversed and edited.</p><p>When iterating, only visits non-empty fields. To discover empty fields, inspect the schema using <a href='/docs/apis/tree#typesymbol-variable'>typeSymbol</a>.</p><p>The tree can be inspected by means of the built-in JS functions e.g.</p>
        ```
        const root = context.unwrappedRoot;
        for (const key of Reflect.ownKeys(root)) { ... }
        // OR
        if ("foo" in root) { ... }
        ```
        <p>where <code>context</code> is a common <code>EditableTreeContext</code>.</p><p>The tree can be edited either by using its symbol-based "toolbox" (e.g. <a href='/docs/apis/tree#createfield-variable'>createField</a>) or using a simple assignment operator (see <code>EditableTreeContext.unwrappedRoot</code> for more details).</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletreecontext-interface'>EditableTreeContext</a>
      </td>
      <td>
        A common context of a "forest" of EditableTrees. It handles group operations like transforming cursors into anchors for edits.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/exception-interface'>Exception</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldadapter-interface'>FieldAdapter</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldanchor-interface'>FieldAnchor</a>
      </td>
      <td>
        Anchor to a field. This is structurally based on the parent, so it will move only as the parent moves.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldchange-interface'>FieldChange</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldchangeencoder-interface'>FieldChangeEncoder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldchangehandler-interface'>FieldChangeHandler</a>
      </td>
      <td>
        Functionality provided by a field kind which will be composed with other <code>FieldChangeHandler</code>s to implement a unified ChangeFamily supporting documents with multiple field kinds.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldchangerebaser-interface'>FieldChangeRebaser</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldeditor-interface'>FieldEditor</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldlocation-interface'>FieldLocation</a>
      </td>
      <td>
        Wrapper around DetachedField that can be detected at runtime.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldmapobject-interface'>FieldMapObject</a>
      </td>
      <td>
        <p>Json compatible map as object. Keys are FieldKey strings. Values are the content of the field specified by the key.</p><p>WARNING: Be very careful when using objects as maps: Use <code>Object.prototype.hasOwnProperty.call(fieldMap, key)</code> to safely check for keys. Do NOT simply read the field and check for undefined as this will return values for <code>__proto__</code> and various methods on Object.prototype, like <code>hasOwnProperty</code> and <code>toString</code>. This exposes numerous bug possibilities, including prototype pollution.</p><p>Due to the above issue, try to avoid this type (and the whole object as map pattern). Only use this type when needed for json compatible maps, but even in those cases consider lists of key value pairs for serialization and using <code>Map</code> for runtime.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fielduppath-interface'>FieldUpPath</a>
      </td>
      <td>
        <p>Path from a field in the tree upward.</p><p>See <a href='/docs/apis/tree/uppath-interface'>UpPath</a>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/finalchange-interface'>FinalChange</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fullschemapolicy-interface'>FullSchemaPolicy</a>
      </td>
      <td>
        Policy from the app for interpreting the stored schema. The app must ensure consistency for all users of the document.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/genericchange-interface'>GenericChange</a>
      </td>
      <td>
        A field-kind-agnostic change to a single node within a field.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/genericfieldsnode-interface'>GenericFieldsNode</a>
      </td>
      <td>
        Json comparable field collection, generic over child type. Json compatibility assumes <code>TChild</code> is also json compatible.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/generictreenode-interface'>GenericTreeNode</a>
      </td>
      <td>
        Json comparable tree node, generic over child type. Json compatibility assumes <code>TChild</code> is also json compatible.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/icachedvalue-interface'>ICachedValue</a>
      </td>
      <td>
        Caches and invalidates a value.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/icheckout-interface'>ICheckout</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/idefaulteditbuilder-interface'>IDefaultEditBuilder</a>
      </td>
      <td>
        Default editor for transactions.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/ieditableforest-interface'>IEditableForest</a>
      </td>
      <td>
        Editing APIs.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/iforestsubscription-interface'>IForestSubscription</a>
      </td>
      <td>
        <p>Invalidates whenever <code>current</code> changes. For now (might change later) downloading new parts of the forest counts as a change.</p><p>When invalidating, all outstanding cursors must be freed or cleared.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/index-interface'>Index</a>
      </td>
      <td>
        Observes Changesets (after rebase), after writes data into summaries when requested.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/invariant-interface'>Invariant</a>
      </td>
      <td>
        Constrain generic type parameters to Invariant.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/isharedtree-interface'>ISharedTree</a>
      </td>
      <td>
        <p>Collaboratively editable tree distributed data-structure, powered by <i>@fluidframework/shared-object-base#ISharedObject</i>.</p><p>See [the README](../../README.md) for details.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/isharedtreecoreevents-interface'>ISharedTreeCoreEvents</a>
      </td>
      <td>
        <p>The events emitted by a <a href='/docs/apis/tree/sharedtreecore-class'>SharedTreeCore</a></p><p>TODO: Add/remove events</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a>
      </td>
      <td>
        A stateful low-level interface for reading tree data.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/itreecursorsynchronous-interface'>ITreeCursorSynchronous</a>
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a> that is never pending.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/itreesubscriptioncursor-interface'>ITreeSubscriptionCursor</a>
      </td>
      <td>
        ITreeCursor supporting IForestSubscription and its changes over time.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/jsonabletree-interface'>JsonableTree</a>
      </td>
      <td>
        <p>A tree represented using plain JavaScript objects. Can be passed to <code>JSON.stringify()</code> to produce a human-readable/editable JSON tree.</p><p>JsonableTrees should not store empty fields.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/makenominal-interface'>MakeNominal</a>
      </td>
      <td>
        <p>Use this as the type of a protected field to cause a type to use nominal typing instead of structural.</p><p>See: <a href='https://dev.azure.com/intentional/intent/_wiki/wikis/NP%20Platform/7146/Nominal-vs-Structural-Types'>https://dev.azure.com/intentional/intent/_wiki/wikis/NP%20Platform/7146/Nominal-vs-Structural-Types</a></p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/maptree-interface'>MapTree</a>
      </td>
      <td>
        Simple in memory tree representation based on Maps. MapTrees should not store empty fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/markedarraylike-interface'>MarkedArrayLike</a>
      </td>
      <td>
        Can be used to mark a type which works like an array, but is not compatible with <code>Array.isArray</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/modularchangeset-interface'>ModularChangeset</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/mutableschemadata-interface'>MutableSchemaData</a>
      </td>
      <td>
        TODO: Doc
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/mutablesummarydata-interface'>MutableSummaryData</a>
      </td>
      <td>
        The in-memory data that summaries contain. Note that this interface gives mutable access to the data. Passed to <a href='/docs/apis/tree#loadsummary-function'>loadSummary()</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/named-interface'>Named</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/namedcomputation-interface'>NamedComputation</a>
      </td>
      <td>
        Computation, with a name.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/nodechangeset-interface'>NodeChangeset</a>
      </td>
      <td>
        Changeset for a subtree rooted at a specific node.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/nodedata-interface'>NodeData</a>
      </td>
      <td>
        The fields required by a node in a tree.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/observingcontext-interface'>ObservingContext</a>
      </td>
      <td>
        State/Environment for a computation which can observe <a href='/docs/apis/tree/dependee-interface'>Dependee</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/observingdependent-interface'>ObservingDependent</a>
      </td>
      <td>
        A dependent which can have observations it makes recorded onto it.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/optionalfieldeditbuilder-interface'>OptionalFieldEditBuilder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/outputtype-interface'>OutputType</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/progressiveeditbuilder-interface'>ProgressiveEditBuilder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/readonlyrepairdatastore-interface'>ReadonlyRepairDataStore</a>
      </td>
      <td>
        An object that can queried for document data that was deleted in prior revisions.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/readonlysummarydata-interface'>ReadonlySummaryData</a>
      </td>
      <td>
        The in-memory data that summaries contain. Passed to <a href='/docs/apis/tree#encodesummary-function'>encodeSummary()</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/repairdatastore-interface'>RepairDataStore</a>
      </td>
      <td>
        An object that captures document data being deleted by changes, and can be queried to retrieve that data.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/rootfield-interface'>RootField</a>
      </td>
      <td>
        Wrapper around DetachedField that can be detected at runtime.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a>
      </td>
      <td>
        <p>View of schema data that can be stored in a document.</p><p>Note: the owner of this may modify it over time: thus if needing to hand onto a specific version, make a copy.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/schemadataandpolicy-interface'>SchemaDataAndPolicy</a>
      </td>
      <td>
        A <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a> with a <a href='/docs/apis/tree/schemapolicy-interface'>SchemaPolicy</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/schemaop-interface'>SchemaOp</a>
      </td>
      <td>
        TODO: doc
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/schemapolicy-interface'>SchemaPolicy</a>
      </td>
      <td>
        Policy from the app for interpreting the stored schema. The app must ensure consistency for all users of the document.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/sequencefieldeditbuilder-interface'>SequenceFieldEditBuilder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/storedschemarepository-interface'>StoredSchemaRepository</a>
      </td>
      <td>
        <p>Mutable collection of stored schema.</p><p>TODO: could implement more fine grained dependency tracking.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/summaryelement-interface'>SummaryElement</a>
      </td>
      <td>
        Specifies the behavior of an <a href='/docs/apis/tree/index-interface'>Index</a> that puts data in a summary.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/taggedchange-interface'>TaggedChange</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treeadapter-interface'>TreeAdapter</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treelocation-interface'>TreeLocation</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treeschemabuilder-interface'>TreeSchemaBuilder</a>
      </td>
      <td>
        See <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a> for details.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treevalue-interface'>TreeValue</a>
      </td>
      <td>
        <p>Value that may be stored on a node.</p><p>TODO: <code>Serializable</code> is not really the right type to use here, since many types (including functions) are "Serializable" (according to the type) despite not being serializable.</p><p>Use this type instead of directly using Serializable for both clarity and so the above TODO can be addressed.</p><p>This is a named interface instead of a Type alias so tooling (ex: refactors) will not replace it with <code>any</code>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a>
      </td>
      <td>
        <p>Path from a location in the tree upward. UpPaths can be used with deduplicated upper parts to allow working with paths localized to part of the tree without incurring costs related to the depth of the local subtree.</p><p>UpPaths can be thought of as terminating at a special root node (that is <code>undefined</code>) who's FieldKeys are all LocalFieldKey's that correspond to detached sequences.</p><p>UpPaths can be mutated over time and should be considered to be invalidated when any edits occurs: Use of an UpPath that was acquired before the most recent edit is undefined behavior.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/valuefieldeditbuilder-interface'>ValueFieldEditBuilder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/violation-interface'>Violation</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Classes

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Class
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/adaptedviewschema-class'>AdaptedViewSchema</a>
      </td>
      <td>
      </td>
      <td>
        A collection of View information for schema, including policy.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/anchorset-class'>AnchorSet</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        <p>Collection of Anchors at a specific revision.</p><p>See <code>Rebaser</code> for how to update across revisions.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/brandedtype-class'>BrandedType</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        <p>Helper for <a href='/docs/apis/tree#brand-typealias'>Brand</a>. This is split out into its own as thats the only way to: - have doc comments for the field. - make the field protected (so you don't accidentally try and read it). - get nominal typing (so types produced without using this class can never be assignable to it). - allow use as <a href='/docs/apis/tree#opaque-typealias'>Opaque</a> branded type (not assignable to <code>ValueType</code>, but captures <code>ValueType</code>).</p><p>See <a href='/docs/apis/tree/makenominal-interface'>MakeNominal</a> for some more details.</p><p>Do not use this class with <code>instanceof</code>: this will always be false at runtime, but the compiler may think its true in some cases.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/changeencoder-class'>ChangeEncoder</a>
      </td>
      <td>
      </td>
      <td>
        <p>Serializes and deserializes changes. Supports both binary and JSON formats. Due to data using these formats being persisted in documents, any format for encoding that was ever actually used should be supported for decoding for all future versions.</p><p>TODO: Nothing in here is specific to changes. Maybe make this interface more general.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/defaultchangefamily-class'>DefaultChangeFamily</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        Implementation of <a href='/docs/apis/tree/changefamily-interface'>ChangeFamily</a> based on the default set of supported field kinds.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/defaulteditbuilder-class'>DefaultEditBuilder</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        Implementation of <a href='/docs/apis/tree/progressiveeditbuilder-interface'>ProgressiveEditBuilder</a> based on the default set of supported field kinds.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/disposingdependee-class'>DisposingDependee</a>
      </td>
      <td>
      </td>
      <td>
        A <a href='/docs/apis/tree/dependee-interface'>Dependee</a> which runs a callback once it removes its last dependent. See <a href='/docs/apis/tree/disposingdependee-class#endinitialization-method'>DisposingDependee.endInitialization()</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editmanager-class'>EditManager</a>
      </td>
      <td>
      </td>
      <td>
        Represents a local branch of a document and interprets the effect on the document of adding sequenced changes, which were based on a given session's branch, to the document history
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editmanagerindex-class'>EditManagerIndex</a>
      </td>
      <td>
      </td>
      <td>
        Represents a local branch of a document and interprets the effect on the document of adding sequenced changes, which were based on a given session's branch, to the document history
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkind-class'>FieldKind</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        <p>Functionality for FieldKinds that is stable, meaning that it can not change in any measurable way without providing a new identifier.</p><p>It is assumed that this information and policy is available on all clients interacting with a document using the identifier.</p><p>This must contain enough information to process remote edits to this FieldKind consistently with all clients. All behavior must be deterministic, and not change across versions of the app/library.</p><p>These policies include the data encoding, change encoding, change rebase and change application.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/forestindex-class'>ForestIndex</a>
      </td>
      <td>
      </td>
      <td>
        <p>Index which provides an editable forest for the current state for the document.</p><p>Maintains part of the document in memory, but can fetch more on demand.</p><p>TODO: support for partial checkouts.</p><p>Used to capture snapshots of document for summaries.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/forestrepairdatastore-class'>ForestRepairDataStore</a>
      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/inmemorystoredschemarepository-class'>InMemoryStoredSchemaRepository</a>
      </td>
      <td>
      </td>
      <td>
        StoredSchemaRepository for in memory use: not hooked up to Fluid (does not create Fluid ops when editing).
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/invalidationtoken-class'>InvalidationToken</a>
      </td>
      <td>
      </td>
      <td>
        Type for providing optional extra data to <a href='/docs/apis/tree/dependent-interface#markinvalid-methodsignature'>Dependent.markInvalid()</a>. Particular instances and/or subclasses can be used to indicate invalidations that can optionally be handled less conservatively than the base invalidated case.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/modularchangefamily-class'>ModularChangeFamily</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        Implementation of ChangeFamily which delegates work in a given field to the appropriate FieldKind as determined by the schema.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/modulareditbuilder-class'>ModularEditBuilder</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/progressiveeditbuilderbase-class'>ProgressiveEditBuilderBase</a>
      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/rebaser-class'>Rebaser</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        A collection of branches which can rebase changes between them.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/schemaeditor-class'>SchemaEditor</a>
      </td>
      <td>
      </td>
      <td>
        <p>Wraps a StoredSchemaRepository, adjusting its "update" function to hook into Fluid Ops.</p><p>TODO: this should be more integrated with both SchemaIndex and transactions.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/schemaindex-class'>SchemaIndex</a>
      </td>
      <td>
      </td>
      <td>
        <p>Index which tracks stored schema for the current state for the document.</p><p>Maintains the schema in memory.</p><p>Used to capture snapshots of schema for summaries, as well as for anything else needing access to stored schema.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/sharedtreecore-class'>SharedTreeCore</a>
      </td>
      <td>
      </td>
      <td>
        <p>Generic shared tree, which needs to be configured with indexes, field kinds and a history policy to be used.</p><p>TODO: actually implement TODO: is history policy a detail of what indexes are used, or is there something else to it?</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/sharedtreefactory-class'>SharedTreeFactory</a>
      </td>
      <td>
      </td>
      <td>
        A channel factory that creates <a href='/docs/apis/tree/isharedtree-interface'>ISharedTree</a>s.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/simpledependee-class'>SimpleDependee</a>
      </td>
      <td>
      </td>
      <td>
        Simple implementation of <a href='/docs/apis/tree/dependee-interface'>Dependee</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/simpleobservingdependent-class'>SimpleObservingDependent</a>
      </td>
      <td>
      </td>
      <td>
        A basic <a href='/docs/apis/tree/observingdependent-interface'>ObservingDependent</a> implementation.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/sparsenode-class'>SparseNode</a>
      </td>
      <td>
      </td>
      <td>
        <p>Sparse Tree of nodes.</p><p>Contains both child and parent pointers, which are kept in sync.</p><p>Each node is equivalent to a path through the tree. This tree structure stores a collection of these paths, but deduplicating the common prefixes of the tree prefix-tree style.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/viewschemadata-class'>ViewSchemaData</a>
      </td>
      <td>
      </td>
      <td>
        A collection of View information for schema, including policy.
      </td>
    </tr>
  </tbody>
</table>

## Enumerations

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Enum
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#compatibility-enum'>Compatibility</a>
      </td>
      <td>
        How compatible a particular view schema is for some operation on some specific document.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#cursorlocationtype-enum'>CursorLocationType</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldscope-enum'>FieldScope</a>
      </td>
      <td>
        The scope of a <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#finalchangestatus-enum'>FinalChangeStatus</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#itreesubscriptioncursorstate-enum'>ITreeSubscriptionCursorState</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-enum'>Multiplicity</a>
      </td>
      <td>
        <p>Describes how a particular field functions.</p><p>This determine its reading and editing APIs, multiplicity, and what merge resolution policies it will use.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#transactionresult-enum'>TransactionResult</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treenavigationresult-enum'>TreeNavigationResult</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-enum'>ValueSchema</a>
      </td>
      <td>
        <p>Example for how we might want to handle values.</p><p>This might be significantly different if we want to focus more on binary formats (need to work out how Fluid GC would work with that). For now, this is a simple easy to support setup.</p><p>Note that use of non-Nothing values might be restricted in the actual user facing schema languages: we could instead choose to get by with the only types supporting values being effectively builtin, though this limitation could prevent users for updating/extending the primitive schema to allow the annotations they might want.</p><p>An interesting alternative to this simple value Enum would be to use something more expressive here, like JsonSchema: since this is modeling immutable data, we really just need a way to figure out which if these value schema allow super sets of each-other.</p><p>TODO: come up with a final design for how to handle primitives / values. This design is just a placeholder.</p>
      </td>
    </tr>
  </tbody>
</table>

## Types

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        TypeAlias
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#anchor-typealias'>Anchor</a>
      </td>
      <td>
        A way to refer to a particular tree location within an <a href='/docs/apis/tree/anchorset-class'>AnchorSet</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#brand-typealias'>Brand</a>
      </td>
      <td>
        <p>Constructs a "Branded" type, adding a type-checking only field to <code>ValueType</code>.</p><p>Two usages of <code>Brand</code> should never use the same <code>Name</code>. If they do, the resulting types will be assignable which defeats the point of this type.</p><p>This type is constructed such that the first line of type errors when assigning mismatched branded types will be: <code>Type 'Name1' is not assignable to type 'Name2'.</code></p><p>These branded types are not opaque: A <code>Brand&lt;A, B&gt;</code> can still be used as a <code>B</code>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#changesetfromchangerebaser-typealias'>ChangesetFromChangeRebaser</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#changesetlocalid-typealias'>ChangesetLocalId</a>
      </td>
      <td>
        An ID which is unique within a revision of a <code>ModularChangeset</code>. A <code>ModularChangeset</code> which is a composition of multiple revisions may contain duplicate <code>ChangesetLocalId</code>s, but they are unique when qualified by the revision of the change they are used in.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#childcollection-typealias'>ChildCollection</a>
      </td>
      <td>
        Identifier for a child collection, either on a node/tree or at the root of a forest.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a>
      </td>
      <td>
        <p>Content of a tree which needs external schema information to interpret.</p><p>This format is intended for concise authoring of tree literals when the schema is statically known.</p><p>Once schema aware APIs are implemented, they can be used to provide schema specific subsets of this type.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#defaultchangeset-typealias'>DefaultChangeset</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#editabletreeorprimitive-typealias'>EditableTreeOrPrimitive</a>
      </td>
      <td>
        EditableTree, but with any type that <code>isPrimitive</code> unwrapped into the value if that value is a <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#extractfromopaque-typealias'>ExtractFromOpaque</a>
      </td>
      <td>
        See <a href='/docs/apis/tree#extractfromopaque-function'>extractFromOpaque()</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#failure-typealias'>Failure</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldchangemap-typealias'>FieldChangeMap</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldchangeset-typealias'>FieldChangeset</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
        <p>Either LocalFieldKey or GlobalFieldKey.</p><p>To avoid collisions, we can not abstract over local and global field keys using the same format for each (that would make telling them apart impossible). Thus global field keys are using their symbols instead.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldkindidentifier-typealias'>FieldKindIdentifier</a>
      </td>
      <td>
        Identifier for a FieldKind. Refers to an exact stable policy (ex: specific version of a policy), for how to handle (ex: edit and merge edits to) fields marked with this kind. Persisted in documents as part of stored schema.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#forestlocation-typealias'>ForestLocation</a>
      </td>
      <td>
        Ways to refer to a node in an IEditableForest.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#genericchangeset-typealias'>GenericChangeset</a>
      </td>
      <td>
        A field-agnostic set of changes to the elements of a field.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#globalfieldkey-typealias'>GlobalFieldKey</a>
      </td>
      <td>
        SchemaIdentifier for a "global field", meaning a field which has the same meaning for all usages within the document (not scoped to a specific TreeSchema like LocalFieldKey).
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
        <p>Symbol which can be used to lookup a global field. Using a symbol here avoids the need to use the full string version of the key, and avoids the possibility of colliding with local field keys.</p><p>Must only be produced using <a href='/docs/apis/tree#symbolfromkey-function'>symbolFromKey()</a>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#idallocator-typealias'>IdAllocator</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isany-typealias'>isAny</a>
      </td>
      <td>
        Returns a type parameter that is true iff T is any.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsoncompatible-typealias'>JsonCompatible</a>
      </td>
      <td>
        <p>Use for Json compatible data.</p><p>Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsoncompatibleobject-typealias'>JsonCompatibleObject</a>
      </td>
      <td>
        <p>Use for Json object compatible data.</p><p>Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsoncompatiblereadonly-typealias'>JsonCompatibleReadOnly</a>
      </td>
      <td>
        <p>Use for readonly view of Json compatible data.</p><p>Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#localfieldkey-typealias'>LocalFieldKey</a>
      </td>
      <td>
        Key (aka Name or Label) for a field which is scoped to a specific TreeSchema.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#namedfieldschema-typealias'>NamedFieldSchema</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#namedtreeschema-typealias'>NamedTreeSchema</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangecomposer-typealias'>NodeChangeComposer</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangedecoder-typealias'>NodeChangeDecoder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangeencoder-typealias'>NodeChangeEncoder</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangeinverter-typealias'>NodeChangeInverter</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodechangerebaser-typealias'>NodeChangeRebaser</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nodereviver-typealias'>NodeReviver</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#opaque-typealias'>Opaque</a>
      </td>
      <td>
        <p>Converts a Branded type into an "opaque" handle. This prevents the value from being used directly, but does not fully type erase it (and this its not really fully opaque): The type can be recovered using <a href='/docs/apis/tree#extractfromopaque-function'>extractFromOpaque()</a>, however if we assume only code that produces these "opaque" handles does that conversion, they can function like opaque handles.</p><p>Recommenced usage is to use <code>interface</code> instead of <code>type</code> so tooling (such as tsc and refactoring tools) uses the type name instead of expanding it:</p>
        ```typescript
        export interface MyType extends Opaque<Brand<string, "myPackage.MyType">>{}
        ```
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#recursivereadonly-typealias'>RecursiveReadonly</a>
      </td>
      <td>
        Make all transitive properties in T readonly
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#revisiontag-typealias'>RevisionTag</a>
      </td>
      <td>
        A way to refer to a particular revision within a given <code>Rebaser</code> instance.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#seqnumber-typealias'>SeqNumber</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#sessionid-typealias'>SessionId</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#summaryelementparser-typealias'>SummaryElementParser</a>
      </td>
      <td>
        Parses a serialized/summarized string into an object, rehydrating any Fluid handles as necessary
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#summaryelementstringifier-typealias'>SummaryElementStringifier</a>
      </td>
      <td>
        Serializes the given contents into a string acceptable for storing in summaries, i.e. all Fluid handles have been replaced appropriately by an IFluidSerializer
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#todelta-typealias'>ToDelta</a>
      </td>
      <td>
        The <code>index</code> represents the index of the child node in the input context. The <code>index</code> should be <code>undefined</code> iff the child node does not exist in the input context (e.g., an inserted node).
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treeschemaidentifier-typealias'>TreeSchemaIdentifier</a>
      </td>
      <td>
        SchemaIdentifier for a Tree. Also known as "Definition"
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treetype-typealias'>TreeType</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treetypeset-typealias'>TreeTypeSet</a>
      </td>
      <td>
        <p>Set of allowed tree types. Providing multiple values here allows polymorphism, tagged union style.</p><p>If not specified, types are unconstrained (equivalent to the set containing every TreeSchemaIdentifier defined in the document).</p><p>Note that even when unconstrained, children must still be in-schema for their own type.</p><p>In the future, this could be extended to allow inlining a TreeSchema here (or some similar structural schema system). For structural types which could go here, there are a few interesting options:</p><p>- Allow replacing the whole set with a structural type for terminal / non-tree data, and use this as a replacement for values on the tree nodes.</p><p>- Allow expression structural constraints for child trees, for example requiring specific traits (ex: via TreeSchema), instead of by type.</p><p>There are two ways this could work:</p><p>- Constrain the child nodes based on their shape: this makes schema safe editing difficult because nodes would incur extra editing constraints to prevent them from going out of schema based on their location in such a field.</p><p>- Constrain the types allowed based on which types guarantee their data will always meet the constraints.</p><p>Care would need to be taken to make sure this is sound for the schema updating mechanisms.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#unwrappededitablefield-typealias'>UnwrappedEditableField</a>
      </td>
      <td>
        Unwrapped field. Non-sequence multiplicities are unwrapped to the child tree or <code>undefined</code> if there is none. Sequence multiplicities are handled with <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>. See <a href='/docs/apis/tree#unwrappededitabletree-typealias'>UnwrappedEditableTree</a> for how the children themselves are unwrapped.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#unwrappededitabletree-typealias'>UnwrappedEditableTree</a>
      </td>
      <td>
        EditableTree, but with these cases of unwrapping: - primitives are unwrapped. See <a href='/docs/apis/tree#editabletreeorprimitive-typealias'>EditableTreeOrPrimitive</a>. - nodes with PrimaryField (see <code>getPrimaryField</code>) are unwrapped to <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>s. - fields are unwrapped based on their schema's multiplicity. See <a href='/docs/apis/tree#unwrappededitablefield-typealias'>UnwrappedEditableField</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#value-typealias'>Value</a>
      </td>
      <td>
        Value stored on a node.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valuechange-typealias'>ValueChange</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Functions

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Function
      </th>
      <th scope="col">
        Return Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#allowsreposuperset-function'>allowsRepoSuperset</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#applymodifytotree-function'>applyModifyToTree</a>
      </td>
      <td>
        Map<<a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>, Delta.MarkList>
      </td>
      <td>
        <p>Converts inserted content into the format expected in Delta instances. This involves applying the following changes:</p><p>- Updating node values</p><p>- Inserting new subtrees within the inserted content</p><p>- Deleting parts of the inserted content</p><p>The only kind of change that is not applied by this function is MoveIn.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#buildforest-function'>buildForest</a>
      </td>
      <td>
        <a href='/docs/apis/tree/ieditableforest-interface'>IEditableForest</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#cachedvalue-function'>cachedValue</a>
      </td>
      <td>
        <a href='/docs/apis/tree/icachedvalue-interface'>ICachedValue</a><T>
      </td>
      <td>
        Create a ICachedValue that is invalidated when <code>observer</code> (as provided to <code>compute</code>) gets invalidated.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#clonepath-function'>clonePath</a>
      </td>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#clonepath_1-function'>clonePath</a>
      </td>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a> | undefined
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#commitencoderfromchangeencoder-function'>commitEncoderFromChangeEncoder</a>
      </td>
      <td>
        <a href='/docs/apis/tree/commitencoder-interface'>CommitEncoder</a><TChangeset>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#comparefielduppaths-function'>compareFieldUpPaths</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#compareuppaths-function'>compareUpPaths</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#cursortojsonobject-function'>cursorToJsonObject</a>
      </td>
      <td>
        <a href='/docs/apis/tree#jsoncompatible-typealias'>JsonCompatible</a>
      </td>
      <td>
        Extract a JS object tree from the contents of the given ITreeCursor. Assumes that ITreeCursor contains only unaugmented JsonTypes.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#detachedfieldaskey-function'>detachedFieldAsKey</a>
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
        Some code abstracts the root as a node with detached fields as its fields. This maps detached field to field keys for thus use.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#encodesummary-function'>encodeSummary</a>
      </td>
      <td>
        string
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#extractfromopaque-function'>extractFromOpaque</a>
      </td>
      <td>
        <a href='/docs/apis/tree#extractfromopaque-typealias'>ExtractFromOpaque</a><TOpaque>
      </td>
      <td>
        <p>Converts a <a href='/docs/apis/tree#opaque-typealias'>Opaque</a> handle to the underlying branded type.</p><p>It is assumed that only code that produces these "opaque" handles does this conversion, allowing these handles to be considered opaque.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldschema-function'>fieldSchema</a>
      </td>
      <td>
        <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>
      </td>
      <td>
        Helper for building <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#foreachfield-function'>forEachField</a>
      </td>
      <td>
        void
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#foreachnode-function'>forEachNode</a>
      </td>
      <td>
        void
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#generictreedeleteifempty-function'>genericTreeDeleteIfEmpty</a>
      </td>
      <td>
        void
      </td>
      <td>
        Delete a field if empty. Optionally delete FieldMapObject if empty as well.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#generictreekeys-function'>genericTreeKeys</a>
      </td>
      <td>
        readonly <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>[]
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#getdepth-function'>getDepth</a>
      </td>
      <td>
        number
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#getdescendant-function'>getDescendant</a>
      </td>
      <td>
        <a href='/docs/apis/tree/sparsenode-class'>SparseNode</a><TData>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#geteditabletreecontext-function'>getEditableTreeContext</a>
      </td>
      <td>
        <a href='/docs/apis/tree/editabletreecontext-interface'>EditableTreeContext</a>
      </td>
      <td>
        A simple API for a Forest to interact with the tree.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#getgenerictreefield-function'>getGenericTreeField</a>
      </td>
      <td>
        T[]
      </td>
      <td>
        Get a field from <code>node</code>, optionally modifying the tree to create it if missing.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#getmaptreefield-function'>getMapTreeField</a>
      </td>
      <td>
        <a href='/docs/apis/tree/maptree-interface'>MapTree</a>[]
      </td>
      <td>
        Get a field from <code>node</code>, optionally modifying the tree to create it if missing.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#getprimaryfield-function'>getPrimaryField</a>
      </td>
      <td>
        { key: <a href='/docs/apis/tree#localfieldkey-typealias'>LocalFieldKey</a>; schema: <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>; } | undefined
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#getschemastring-function'>getSchemaString</a>
      </td>
      <td>
        string
      </td>
      <td>
        <p>Synchronous monolithic summarization of schema content.</p><p>TODO: when perf matters, this should be replaced with a chunked async version using a binary format.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#initializeforest-function'>initializeForest</a>
      </td>
      <td>
        void
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#iscontextuallytypednodedataobject-function'>isContextuallyTypedNodeDataObject</a>
      </td>
      <td>
        data is <a href='/docs/apis/tree/contextuallytypednodedataobject-interface'>ContextuallyTypedNodeDataObject</a>
      </td>
      <td>
        Checks the type of a <code>ContextuallyTypedNodeData</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#iseditablefield-function'>isEditableField</a>
      </td>
      <td>
        field is <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>
      </td>
      <td>
        Checks the type of an UnwrappedEditableField.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isfieldlocation-function'>isFieldLocation</a>
      </td>
      <td>
        range is <a href='/docs/apis/tree/fieldlocation-interface'>FieldLocation</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isglobalfieldkey-function'>isGlobalFieldKey</a>
      </td>
      <td>
        key is <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
        Derives the scope using the type of <code>key</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#islocalkey-function'>isLocalKey</a>
      </td>
      <td>
        key is <a href='/docs/apis/tree#localfieldkey-typealias'>LocalFieldKey</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isneverfield-function'>isNeverField</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isprimitive-function'>isPrimitive</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isprimitivevalue-function'>isPrimitiveValue</a>
      </td>
      <td>
        nodeValue is <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#isunwrappednode-function'>isUnwrappedNode</a>
      </td>
      <td>
        field is <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a>
      </td>
      <td>
        Checks the type of an UnwrappedEditableField.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#iswritablearraylike-function'>isWritableArrayLike</a>
      </td>
      <td>
        data is <a href='/docs/apis/tree/markedarraylike-interface'>MarkedArrayLike</a><<a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a>>
      </td>
      <td>
        Checks the type of a <code>ContextuallyTypedNodeData</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonabletreefromcursor-function'>jsonableTreeFromCursor</a>
      </td>
      <td>
        <a href='/docs/apis/tree/jsonabletree-interface'>JsonableTree</a>
      </td>
      <td>
        Extract a JsonableTree from the contents of the given ITreeCursor's current node.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#keyasdetachedfield-function'>keyAsDetachedField</a>
      </td>
      <td>
        <a href='/docs/apis/tree/detachedfield-interface'>DetachedField</a>
      </td>
      <td>
        The inverse of <a href='/docs/apis/tree#detachedfieldaskey-function'>detachedFieldAsKey()</a>. Thus must only be used on <a href='/docs/apis/tree#localfieldkey-typealias'>LocalFieldKey</a>s which were produced via <a href='/docs/apis/tree#detachedfieldaskey-function'>detachedFieldAsKey()</a>, and with the same scope (ex: forest) as the detachedFieldAsKey was originally from.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#keyfromsymbol-function'>keyFromSymbol</a>
      </td>
      <td>
        <a href='/docs/apis/tree#globalfieldkey-typealias'>GlobalFieldKey</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#loadsummary-function'>loadSummary</a>
      </td>
      <td>
        void
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#lookupglobalfieldschema-function'>lookupGlobalFieldSchema</a>
      </td>
      <td>
        <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#lookuptreeschema-function'>lookupTreeSchema</a>
      </td>
      <td>
        <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#makeanonchange-function'>makeAnonChange</a>
      </td>
      <td>
        <a href='/docs/apis/tree/taggedchange-interface'>TaggedChange</a><T>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#mapcursorfield-function'>mapCursorField</a>
      </td>
      <td>
        T[]
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#mapcursorfields-function'>mapCursorFields</a>
      </td>
      <td>
        T[]
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#mapfieldmarks-function'>mapFieldMarks</a>
      </td>
      <td>
        Delta.FieldMarks<TOut>
      </td>
      <td>
        <p>Converts a <code>Delta.FieldMarks</code> whose tree content is represented with by <code>TIn</code> instances into a <code>Delta.FieldMarks</code>whose tree content is represented with by <code>TOut</code> instances.</p><p>This function is useful for converting <code>Delta</code>s that represent tree content with cursors into <code>Delta</code>s that represent tree content with a deep-comparable representation of the content. See assertDeltaEqual. TODO: link this</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#mapfromnamed-function'>mapFromNamed</a>
      </td>
      <td>
        Map<TName, T>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#mapmark-function'>mapMark</a>
      </td>
      <td>
        Delta.Mark<TOut>
      </td>
      <td>
        <p>Converts a <code>Delta.Mark</code> whose tree content is represented with by <code>TIn</code> instances into a <code>Delta.Mark</code>whose tree content is represented with by <code>TOut</code> instances.</p><p>This function is useful for converting <code>Delta</code>s that represent tree content with cursors into <code>Delta</code>s that represent tree content with a deep-comparable representation of the content. See assertMarkListEqual. TODO: link this</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#mapmarklist-function'>mapMarkList</a>
      </td>
      <td>
        Delta.MarkList<TOut>
      </td>
      <td>
        <p>Converts a <code>Delta.MarkList</code> whose tree content is represented with by <code>TIn</code> instances into a <code>Delta.MarkList</code>whose tree content is represented with by <code>TOut</code> instances.</p><p>This function is useful for converting <code>Delta</code>s that represent tree content with cursors into <code>Delta</code>s that represent tree content with a deep-comparable representation of the content. See assertMarkListEqual. TODO: link this</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#maptreefromcursor-function'>mapTreeFromCursor</a>
      </td>
      <td>
        <a href='/docs/apis/tree/maptree-interface'>MapTree</a>
      </td>
      <td>
        Extract a MapTree from the contents of the given ITreeCursor's current node.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#movetodetachedfield-function'>moveToDetachedField</a>
      </td>
      <td>
        void
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#namedtreeschema-function'>namedTreeSchema</a>
      </td>
      <td>
        <a href='/docs/apis/tree#namedtreeschema-typealias'>NamedTreeSchema</a>
      </td>
      <td>
        Helper for building <a href='/docs/apis/tree#namedtreeschema-typealias'>NamedTreeSchema</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#recorddependency-function'>recordDependency</a>
      </td>
      <td>
        void
      </td>
      <td>
        Ensures this context's computation is a dependant to dependee (adding it if needed). Ensures this context's computation has dependee as a dependee (adding it if needed).
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#runsynchronoustransaction-function'>runSynchronousTransaction</a>
      </td>
      <td>
        <a href='/docs/apis/tree#transactionresult-enum'>TransactionResult</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#schemadataisempty-function'>schemaDataIsEmpty</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#scopefromkey-function'>scopeFromKey</a>
      </td>
      <td>
        [<a href='/docs/apis/tree#fieldscope-enum'>FieldScope</a>, <a href='/docs/apis/tree#localfieldkey-typealias'>LocalFieldKey</a> | <a href='/docs/apis/tree#globalfieldkey-typealias'>GlobalFieldKey</a>]
      </td>
      <td>
        Derives the scope using the type of <code>key</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#setgenerictreefield-function'>setGenericTreeField</a>
      </td>
      <td>
        void
      </td>
      <td>
        Sets a field on <code>node</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#singlejsoncursor-function'>singleJsonCursor</a>
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursorsynchronous-interface'>ITreeCursorSynchronous</a>
      </td>
      <td>
        Used to read a Jsonable tree for testing and benchmarking.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#singlemaptreecursor-function'>singleMapTreeCursor</a>
      </td>
      <td>
        <a href='/docs/apis/tree/cursorwithnode-interface'>CursorWithNode</a><<a href='/docs/apis/tree/maptree-interface'>MapTree</a>>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#singlestacktreecursor-function'>singleStackTreeCursor</a>
      </td>
      <td>
        <a href='/docs/apis/tree/cursorwithnode-interface'>CursorWithNode</a><TNode>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#singletextcursor-function'>singleTextCursor</a>
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursorsynchronous-interface'>ITreeCursorSynchronous</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#symbolfromkey-function'>symbolFromKey</a>
      </td>
      <td>
        <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#symbolisfieldkey-function'>symbolIsFieldKey</a>
      </td>
      <td>
        key is <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#tagchange-function'>tagChange</a>
      </td>
      <td>
        <a href='/docs/apis/tree/taggedchange-interface'>TaggedChange</a><T>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#taginverse-function'>tagInverse</a>
      </td>
      <td>
        <a href='/docs/apis/tree/taggedchange-interface'>TaggedChange</a><T>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treeschema-function'>treeSchema</a>
      </td>
      <td>
        <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>
      </td>
      <td>
        Helper for building <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#verifychangerebaser-function'>verifyChangeRebaser</a>
      </td>
      <td>
        <a href='/docs/apis/tree/outputtype-interface'>OutputType</a><TChange>
      </td>
      <td>
        Verifies the axioms of <code>ChangeRebaser</code> are met by the given <code>rebaser</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#visitdelta-function'>visitDelta</a>
      </td>
      <td>
        void
      </td>
      <td>
        Crawls the given <code>delta</code>, calling <code>visitor</code>'s callback for each change encountered. Each successive call to the visitor callbacks assumes that the change described by earlier calls have been applied to the document tree. For example, for a change that deletes the first and third node of a field, the visitor calls will pass indices 0 and 1 respectively.
      </td>
    </tr>
  </tbody>
</table>

## Variables

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Variable
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#afterchangetoken-variable'>afterChangeToken</a>
      </td>
      <td>
        This <code>InvalidationToken</code> is used to indicate that the invalidation of Dependents happens after the Delta is applied to the forest. It is a workaround i.e. definitely a misuse of the invalidation system in an absence of alternative notification/eventing system.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#createfield-variable'>createField</a>
      </td>
      <td>
        A symbol to get the function, which creates a new field of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a>, in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#defaultchangefamily-variable'>defaultChangeFamily</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#defaultschemapolicy-variable'>defaultSchemaPolicy</a>
      </td>
      <td>
        <p>FullSchemaPolicy the default field kinds, empty default fields and neverTree for the default tree schema.</p><p>This requires new node types to have explicit stored schema to exist in documents, and allows adding new global fields along with their schema at any point.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#dummyrepairdatastore-variable'>dummyRepairDataStore</a>
      </td>
      <td>
        A <code>RepairDataStore</code> implementation that returns dummy content.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#emptyfield-variable'>emptyField</a>
      </td>
      <td>
        FieldSchema which is impossible to put anything in.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#emptykey-variable'>EmptyKey</a>
      </td>
      <td>
        <p>The empty key ("") is used for unnamed relationships, such as the indexer of an explicit array node.</p><p>This key is a hint that this field is the primary function of the node, and in some abstractions the APIs for this field should be inlined onto the node.</p><p>TODO: This has to be a LocalFieldKey since different nodes will have different FieldSchema for it. This makes it prone to collisions and suggests that this intention may be better conveyed by metadata on the TreeViewSchema.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#emptymap-variable'>emptyMap</a>
      </td>
      <td>
        Empty readonly map.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#emptyset-variable'>emptySet</a>
      </td>
      <td>
        Empty readonly set.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#genericfieldkind-variable'>genericFieldKind</a>
      </td>
      <td>
        <a href='/docs/apis/tree/fieldkind-class'>FieldKind</a> used to represent changes to elements of a field in a field-kind-agnostic format.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#getfield-variable'>getField</a>
      </td>
      <td>
        A symbol to get the function, which returns the field of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> without unwrapping, in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#indexsymbol-variable'>indexSymbol</a>
      </td>
      <td>
        A symbol to get the index of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> within its parent field in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonarray-variable'>jsonArray</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonboolean-variable'>jsonBoolean</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonnull-variable'>jsonNull</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonnumber-variable'>jsonNumber</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonobject-variable'>jsonObject</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonroot-variable'>jsonRoot</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonschemadata-variable'>jsonSchemaData</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#jsonstring-variable'>jsonString</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#neverfield-variable'>neverField</a>
      </td>
      <td>
        FieldSchema which is impossible for any data to be in schema with.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nevertree-variable'>neverTree</a>
      </td>
      <td>
        TreeSchema which is impossible for any data to be in schema with.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#nofailure-variable'>noFailure</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#proxytargetsymbol-variable'>proxyTargetSymbol</a>
      </td>
      <td>
        A symbol for extracting target from <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> proxies. Useful for debugging and testing, but not part of the public API.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#replacefield-variable'>replaceField</a>
      </td>
      <td>
        A symbol to get the function, which replaces a field of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a>, in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#rootfield-variable'>rootField</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#rootfieldkey-variable'>rootFieldKey</a>
      </td>
      <td>
        GlobalFieldKey to use for the root of documents. TODO: if we do want to standardize on a single value for this, it likely should be namespaced or a UUID to avoid risk of collisions.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#rootfieldkeysymbol-variable'>rootFieldKeySymbol</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#typenamesymbol-variable'>typeNameSymbol</a>
      </td>
      <td>
        A symbol to get the type name of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#typesymbol-variable'>typeSymbol</a>
      </td>
      <td>
        A symbol to get the type of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> in contexts where string keys are already in use for fields.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valuesymbol-variable'>valueSymbol</a>
      </td>
      <td>
        <p>A symbol to get and set the value of <a href='/docs/apis/tree/editabletree-interface'>EditableTree</a> in contexts where string keys are already in use for fields.</p><p>Setting the value using the simple assignment operator (<code>=</code>) is only supported for <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>s. Concurrently setting the value will follow the "last-write-wins" semantics.</p>
      </td>
    </tr>
  </tbody>
</table>

## Namespaces

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Namespace
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/delta-namespace'>Delta</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace'>FieldKinds</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/sequencefield-namespace'>SequenceField</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Enumeration Details

### Compatibility {#compatibility-enum}

How compatible a particular view schema is for some operation on some specific document.

#### Signature {#compatibility-signature}

```typescript
export declare enum Compatibility
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#compatibility-compatible-enummember'>Compatible</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#compatibility-incompatible-enummember'>Incompatible</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#compatibility-requiresadapters-enummember'>RequiresAdapters</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Compatible {#compatibility-compatible-enummember}

###### Signature {#compatible-signature}

```typescript
Compatible = 2;
```

##### Incompatible {#compatibility-incompatible-enummember}

###### Signature {#incompatible-signature}

```typescript
Incompatible = 0;
```

##### RequiresAdapters {#compatibility-requiresadapters-enummember}

###### Signature {#requiresadapters-signature}

```typescript
RequiresAdapters = 1;
```

### CursorLocationType {#cursorlocationtype-enum}

#### Signature {#cursorlocationtype-signature}

```typescript
export declare const enum CursorLocationType
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#cursorlocationtype-fields-enummember'>Fields</a>
      </td>
      <td>
        Can iterate through fields of a node. At a "current field".
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#cursorlocationtype-nodes-enummember'>Nodes</a>
      </td>
      <td>
        Can iterate through nodes in a field. At a "current node".
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Fields {#cursorlocationtype-fields-enummember}

Can iterate through fields of a node. At a "current field".

###### Signature {#fields-signature}

```typescript
Fields = 1;
```

##### Nodes {#cursorlocationtype-nodes-enummember}

Can iterate through nodes in a field. At a "current node".

###### Signature {#nodes-signature}

```typescript
Nodes = 0;
```

### FieldScope {#fieldscope-enum}

The scope of a [FieldKey](/docs/apis/tree#fieldkey-typealias)<!-- -->.

#### Signature {#fieldscope-signature}

```typescript
export declare const enum FieldScope
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldscope-global-enummember'>global</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#fieldscope-local-enummember'>local</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### global {#fieldscope-global-enummember}

###### Signature {#global-signature}

```typescript
global = "globalFields";
```

##### local {#fieldscope-local-enummember}

###### Signature {#local-signature}

```typescript
local = "fields";
```

### FinalChangeStatus {#finalchangestatus-enum}

#### Signature {#finalchangestatus-signature}

```typescript
export declare enum FinalChangeStatus
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#finalchangestatus-commuted-enummember'>commuted</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#finalchangestatus-conflicted-enummember'>conflicted</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#finalchangestatus-rebased-enummember'>rebased</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### commuted {#finalchangestatus-commuted-enummember}

###### Signature {#commuted-signature}

```typescript
commuted = 2;
```

##### conflicted {#finalchangestatus-conflicted-enummember}

###### Signature {#conflicted-signature}

```typescript
conflicted = 0;
```

##### rebased {#finalchangestatus-rebased-enummember}

###### Signature {#rebased-signature}

```typescript
rebased = 1;
```

### ITreeSubscriptionCursorState {#itreesubscriptioncursorstate-enum}

#### Signature {#itreesubscriptioncursorstate-signature}

```typescript
export declare enum ITreeSubscriptionCursorState
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#itreesubscriptioncursorstate-cleared-enummember'>Cleared</a>
      </td>
      <td>
        Empty, but can be reused.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#itreesubscriptioncursorstate-current-enummember'>Current</a>
      </td>
      <td>
        On the current revision of the forest.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#itreesubscriptioncursorstate-freed-enummember'>Freed</a>
      </td>
      <td>
        Freed and must not be used.
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Cleared {#itreesubscriptioncursorstate-cleared-enummember}

Empty, but can be reused.

###### Signature {#cleared-signature}

```typescript
Cleared = 1;
```

##### Current {#itreesubscriptioncursorstate-current-enummember}

On the current revision of the forest.

###### Signature {#current-signature}

```typescript
Current = 0;
```

##### Freed {#itreesubscriptioncursorstate-freed-enummember}

Freed and must not be used.

###### Signature {#freed-signature}

```typescript
Freed = 2;
```

### Multiplicity {#multiplicity-enum}

Describes how a particular field functions.

This determine its reading and editing APIs, multiplicity, and what merge resolution policies it will use.

#### Signature {#multiplicity-signature}

```typescript
export declare enum Multiplicity
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-forbidden-enummember'>Forbidden</a>
      </td>
      <td>
        <p>Exactly 0 items.</p><p>Using Forbidden makes what types are listed for allowed in a field irrelevant since the field will never have values in it.</p><p>Using Forbidden is equivalent to picking a kind that permits empty (like sequence or optional) and having no allowed types (or only never types). Because of this, its possible to express everything constraint wise without Forbidden, but using Forbidden can be more semantically clear than optional with no allowed types.</p><p>For view schema, this can be useful if you need to: - run a specific out of schema handler when a field is present, but otherwise are ignoring or tolerating (ex: via extra fields) unmentioned fields. - prevent a specific field from being used as an extra field (perhaps for some past of future compatibility reason) - keep a field in a schema for metadata purposes (ex: for improved error messaging, error handling or documentation) that is not used in this specific version of the schema (ex: to document what it was or will be used for).</p><p>For stored schema, this can be useful if you need to: - have a field which can have its schema updated to Optional or Sequence of any type. - to exclude a field from extra fields - for the schema system to use as a default for fields which aren't declared (ex: when updating a field that did not exist into one that does)</p><p>See <a href='/docs/apis/tree#emptyfield-variable'>emptyField</a> for a constant, reusable field using Forbidden.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-optional-enummember'>Optional</a>
      </td>
      <td>
        0 or 1 items.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-sequence-enummember'>Sequence</a>
      </td>
      <td>
        0 or more items.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#multiplicity-value-enummember'>Value</a>
      </td>
      <td>
        Exactly one item.
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Forbidden {#multiplicity-forbidden-enummember}

Exactly 0 items.

Using Forbidden makes what types are listed for allowed in a field irrelevant since the field will never have values in it.

Using Forbidden is equivalent to picking a kind that permits empty (like sequence or optional) and having no allowed types (or only never types). Because of this, its possible to express everything constraint wise without Forbidden, but using Forbidden can be more semantically clear than optional with no allowed types.

For view schema, this can be useful if you need to: - run a specific out of schema handler when a field is present, but otherwise are ignoring or tolerating (ex: via extra fields) unmentioned fields. - prevent a specific field from being used as an extra field (perhaps for some past of future compatibility reason) - keep a field in a schema for metadata purposes (ex: for improved error messaging, error handling or documentation) that is not used in this specific version of the schema (ex: to document what it was or will be used for).

For stored schema, this can be useful if you need to: - have a field which can have its schema updated to Optional or Sequence of any type. - to exclude a field from extra fields - for the schema system to use as a default for fields which aren't declared (ex: when updating a field that did not exist into one that does)

See [emptyField](/docs/apis/tree#emptyfield-variable) for a constant, reusable field using Forbidden.

###### Signature {#forbidden-signature}

```typescript
Forbidden = 3;
```

##### Optional {#multiplicity-optional-enummember}

0 or 1 items.

###### Signature {#optional-signature}

```typescript
Optional = 1;
```

##### Sequence {#multiplicity-sequence-enummember}

0 or more items.

###### Signature {#sequence-signature}

```typescript
Sequence = 2;
```

##### Value {#multiplicity-value-enummember}

Exactly one item.

###### Signature {#value-signature}

```typescript
Value = 0;
```

### TransactionResult {#transactionresult-enum}

#### Signature {#transactionresult-signature}

```typescript
export declare enum TransactionResult
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#transactionresult-abort-enummember'>Abort</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#transactionresult-apply-enummember'>Apply</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Abort {#transactionresult-abort-enummember}

###### Signature {#abort-signature}

```typescript
Abort = 0;
```

##### Apply {#transactionresult-apply-enummember}

###### Signature {#apply-signature}

```typescript
Apply = 1;
```

### TreeNavigationResult {#treenavigationresult-enum}

#### Signature {#treenavigationresult-signature}

```typescript
export declare const enum TreeNavigationResult
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#treenavigationresult-notfound-enummember'>NotFound</a>
      </td>
      <td>
        Attempt to navigate cursor to a key or index that is outside the client's view.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treenavigationresult-ok-enummember'>Ok</a>
      </td>
      <td>
        ITreeReader successfully navigated to the desired node.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#treenavigationresult-pending-enummember'>Pending</a>
      </td>
      <td>
        Attempt to navigate cursor to a portion of the tree that has not yet been loaded.
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### NotFound {#treenavigationresult-notfound-enummember}

Attempt to navigate cursor to a key or index that is outside the client's view.

###### Signature {#notfound-signature}

```typescript
NotFound = -1;
```

##### Ok {#treenavigationresult-ok-enummember}

ITreeReader successfully navigated to the desired node.

###### Signature {#ok-signature}

```typescript
Ok = 1;
```

##### Pending {#treenavigationresult-pending-enummember}

Attempt to navigate cursor to a portion of the tree that has not yet been loaded.

###### Signature {#pending-signature}

```typescript
Pending = 0;
```

### ValueSchema {#valueschema-enum}

Example for how we might want to handle values.

This might be significantly different if we want to focus more on binary formats (need to work out how Fluid GC would work with that). For now, this is a simple easy to support setup.

Note that use of non-Nothing values might be restricted in the actual user facing schema languages: we could instead choose to get by with the only types supporting values being effectively builtin, though this limitation could prevent users for updating/extending the primitive schema to allow the annotations they might want.

An interesting alternative to this simple value Enum would be to use something more expressive here, like JsonSchema: since this is modeling immutable data, we really just need a way to figure out which if these value schema allow super sets of each-other.

TODO: come up with a final design for how to handle primitives / values. This design is just a placeholder.

#### Signature {#valueschema-signature}

```typescript
export declare enum ValueSchema
```

#### Flags

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Flag
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-boolean-enummember'>Boolean</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-nothing-enummember'>Nothing</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-number-enummember'>Number</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-serializable-enummember'>Serializable</a>
      </td>
      <td>
        <p>Any Fluid serializable data.</p><p>This includes Nothing / undefined.</p><p>If it is desired to not include Nothing here, <code>anyNode</code> and <code>allowsValueSuperset</code> would need adjusting.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree#valueschema-string-enummember'>String</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### FlagDetails

##### Boolean {#valueschema-boolean-enummember}

###### Signature {#boolean-signature}

```typescript
Boolean = 3;
```

##### Nothing {#valueschema-nothing-enummember}

###### Signature {#nothing-signature}

```typescript
Nothing = 0;
```

##### Number {#valueschema-number-enummember}

###### Signature {#number-signature}

```typescript
Number = 1;
```

##### Serializable {#valueschema-serializable-enummember}

Any Fluid serializable data.

This includes Nothing / undefined.

If it is desired to not include Nothing here, `anyNode` and `allowsValueSuperset` would need adjusting.

###### Signature {#serializable-signature}

```typescript
Serializable = 4;
```

##### String {#valueschema-string-enummember}

###### Signature {#string-signature}

```typescript
String = 2;
```

## Type Details

### Anchor {#anchor-typealias}

A way to refer to a particular tree location within an [AnchorSet](/docs/apis/tree/anchorset-class)<!-- -->.

#### Signature {#anchor-signature}

```typescript
export declare type Anchor = Brand<number, "rebaser.Anchor">;
```

### Brand {#brand-typealias}

Constructs a "Branded" type, adding a type-checking only field to `ValueType`<!-- -->.

Two usages of `Brand` should never use the same `Name`<!-- -->. If they do, the resulting types will be assignable which defeats the point of this type.

This type is constructed such that the first line of type errors when assigning mismatched branded types will be: `Type 'Name1' is not assignable to type 'Name2'.`

These branded types are not opaque: A `Brand<A, B>` can still be used as a `B`<!-- -->.

#### Signature {#brand-signature}

```typescript
export declare type Brand<ValueType, Name extends string> = ValueType &
    BrandedType<ValueType, Name>;
```

### ChangesetFromChangeRebaser {#changesetfromchangerebaser-typealias}

#### Signature {#changesetfromchangerebaser-signature}

```typescript
export declare type ChangesetFromChangeRebaser<TChangeRebaser extends ChangeRebaser<any>> =
    TChangeRebaser extends ChangeRebaser<infer TChangeset> ? TChangeset : never;
```

### ChangesetLocalId {#changesetlocalid-typealias}

An ID which is unique within a revision of a `ModularChangeset`<!-- -->. A `ModularChangeset` which is a composition of multiple revisions may contain duplicate `ChangesetLocalId`<!-- -->s, but they are unique when qualified by the revision of the change they are used in.

#### Signature {#changesetlocalid-signature}

```typescript
export declare type ChangesetLocalId = Brand<number, "ChangesetLocalId">;
```

### ChildCollection {#childcollection-typealias}

Identifier for a child collection, either on a node/tree or at the root of a forest.

#### Signature {#childcollection-signature}

```typescript
export declare type ChildCollection = FieldKey | RootField;
```

### ContextuallyTypedNodeData {#contextuallytypednodedata-typealias}

Content of a tree which needs external schema information to interpret.

This format is intended for concise authoring of tree literals when the schema is statically known.

Once schema aware APIs are implemented, they can be used to provide schema specific subsets of this type.

#### Signature {#contextuallytypednodedata-signature}

```typescript
export declare type ContextuallyTypedNodeData =
    | ContextuallyTypedNodeDataObject
    | PrimitiveValue
    | readonly ContextuallyTypedNodeData[]
    | MarkedArrayLike<ContextuallyTypedNodeData>;
```

### DefaultChangeset {#defaultchangeset-typealias}

#### Signature {#defaultchangeset-signature}

```typescript
export declare type DefaultChangeset = ModularChangeset;
```

### EditableTreeOrPrimitive {#editabletreeorprimitive-typealias}

EditableTree, but with any type that `isPrimitive` unwrapped into the value if that value is a [PrimitiveValue](/docs/apis/tree#primitivevalue-typealias)<!-- -->.

#### Signature {#editabletreeorprimitive-signature}

```typescript
export declare type EditableTreeOrPrimitive = EditableTree | PrimitiveValue;
```

### ExtractFromOpaque {#extractfromopaque-typealias}

See [extractFromOpaque()](/docs/apis/tree#extractfromopaque-function)<!-- -->.

#### Signature {#extractfromopaque-signature}

```typescript
export declare type ExtractFromOpaque<TOpaque extends BrandedType<any, string>> =
    TOpaque extends BrandedType<infer ValueType, infer Name>
        ? isAny<ValueType> extends true
            ? unknown
            : Brand<ValueType, Name>
        : never;
```

### Failure {#failure-typealias}

#### Signature {#failure-signature}

```typescript
export declare type Failure<TCase> = Violation<TCase> | Exception<TCase>;
```

### FieldChangeMap {#fieldchangemap-typealias}

#### Signature {#fieldchangemap-signature}

```typescript
export declare type FieldChangeMap = Map<FieldKey, FieldChange>;
```

### FieldChangeset {#fieldchangeset-typealias}

#### Signature {#fieldchangeset-signature}

```typescript
export declare type FieldChangeset = Brand<unknown, "FieldChangeset">;
```

### FieldKey {#fieldkey-typealias}

Either LocalFieldKey or GlobalFieldKey.

To avoid collisions, we can not abstract over local and global field keys using the same format for each (that would make telling them apart impossible). Thus global field keys are using their symbols instead.

#### Signature {#fieldkey-signature}

```typescript
export declare type FieldKey = LocalFieldKey | GlobalFieldKeySymbol;
```

### FieldKindIdentifier {#fieldkindidentifier-typealias}

Identifier for a FieldKind. Refers to an exact stable policy (ex: specific version of a policy), for how to handle (ex: edit and merge edits to) fields marked with this kind. Persisted in documents as part of stored schema.

#### Signature {#fieldkindidentifier-signature}

```typescript
export declare type FieldKindIdentifier = Brand<string, "tree.FieldKindIdentifier">;
```

### ForestLocation {#forestlocation-typealias}

Ways to refer to a node in an IEditableForest.

#### Signature {#forestlocation-signature}

```typescript
export declare type ForestLocation = ITreeSubscriptionCursor | Anchor;
```

### GenericChangeset {#genericchangeset-typealias}

A field-agnostic set of changes to the elements of a field.

#### Signature {#genericchangeset-signature}

```typescript
export declare type GenericChangeset = GenericChange[];
```

### GlobalFieldKey {#globalfieldkey-typealias}

SchemaIdentifier for a "global field", meaning a field which has the same meaning for all usages within the document (not scoped to a specific TreeSchema like LocalFieldKey).

#### Signature {#globalfieldkey-signature}

```typescript
export declare type GlobalFieldKey = Brand<string, "tree.GlobalFieldKey">;
```

### GlobalFieldKeySymbol {#globalfieldkeysymbol-typealias}

Symbol which can be used to lookup a global field. Using a symbol here avoids the need to use the full string version of the key, and avoids the possibility of colliding with local field keys.

Must only be produced using [symbolFromKey()](/docs/apis/tree#symbolfromkey-function)<!-- -->.

#### Signature {#globalfieldkeysymbol-signature}

```typescript
export declare type GlobalFieldKeySymbol = Brand<symbol, "GlobalFieldKeySymbol">;
```

### IdAllocator {#idallocator-typealias}

#### Signature {#idallocator-signature}

```typescript
export declare type IdAllocator = () => ChangesetLocalId;
```

### isAny {#isany-typealias}

Returns a type parameter that is true iff T is any.

#### Signature {#isany-signature}

```typescript
export declare type isAny<T> = boolean extends (T extends {} ? true : false) ? true : false;
```

### JsonCompatible {#jsoncompatible-typealias}

Use for Json compatible data.

Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.

#### Signature {#jsoncompatible-signature}

```typescript
export declare type JsonCompatible =
    | string
    | number
    | boolean
    | null
    | JsonCompatible[]
    | JsonCompatibleObject;
```

### JsonCompatibleObject {#jsoncompatibleobject-typealias}

Use for Json object compatible data.

Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.

#### Signature {#jsoncompatibleobject-signature}

```typescript
export declare type JsonCompatibleObject = {
    [P in string]: JsonCompatible;
};
```

### JsonCompatibleReadOnly {#jsoncompatiblereadonly-typealias}

Use for readonly view of Json compatible data.

Note that this does not robustly forbid non json comparable data via type checking, but instead mostly restricts access to it.

#### Signature {#jsoncompatiblereadonly-signature}

```typescript
export declare type JsonCompatibleReadOnly =
    | string
    | number
    | boolean
    | null
    | readonly JsonCompatibleReadOnly[]
    | {
          readonly [P in string]: JsonCompatibleReadOnly | undefined;
      };
```

### LocalFieldKey {#localfieldkey-typealias}

Key (aka Name or Label) for a field which is scoped to a specific TreeSchema.

#### Signature {#localfieldkey-signature}

```typescript
export declare type LocalFieldKey = Brand<string, "tree.LocalFieldKey">;
```

### NamedFieldSchema {#namedfieldschema-typealias}

#### Signature {#namedfieldschema-signature}

```typescript
export declare type NamedFieldSchema = Named<GlobalFieldKey> & FieldSchema;
```

### NamedTreeSchema {#namedtreeschema-typealias}

#### Signature {#namedtreeschema-signature}

```typescript
export declare type NamedTreeSchema = TreeSchema & Named<TreeSchemaIdentifier>;
```

### NodeChangeComposer {#nodechangecomposer-typealias}

#### Signature {#nodechangecomposer-signature}

```typescript
export declare type NodeChangeComposer = (changes: TaggedChange<NodeChangeset>[]) => NodeChangeset;
```

### NodeChangeDecoder {#nodechangedecoder-typealias}

#### Signature {#nodechangedecoder-signature}

```typescript
export declare type NodeChangeDecoder = (change: JsonCompatibleReadOnly) => NodeChangeset;
```

### NodeChangeEncoder {#nodechangeencoder-typealias}

#### Signature {#nodechangeencoder-signature}

```typescript
export declare type NodeChangeEncoder = (change: NodeChangeset) => JsonCompatibleReadOnly;
```

### NodeChangeInverter {#nodechangeinverter-typealias}

#### Signature {#nodechangeinverter-signature}

```typescript
export declare type NodeChangeInverter = (change: NodeChangeset) => NodeChangeset;
```

### NodeChangeRebaser {#nodechangerebaser-typealias}

#### Signature {#nodechangerebaser-signature}

```typescript
export declare type NodeChangeRebaser = (
    change: NodeChangeset,
    baseChange: NodeChangeset,
) => NodeChangeset;
```

### NodeReviver {#nodereviver-typealias}

#### Signature {#nodereviver-signature}

```typescript
export declare type NodeReviver = (
    revision: RevisionTag,
    index: number,
    count: number,
) => Delta.ProtoNode[];
```

### Opaque {#opaque-typealias}

Converts a Branded type into an "opaque" handle. This prevents the value from being used directly, but does not fully type erase it (and this its not really fully opaque): The type can be recovered using [extractFromOpaque()](/docs/apis/tree#extractfromopaque-function)<!-- -->, however if we assume only code that produces these "opaque" handles does that conversion, they can function like opaque handles.

Recommenced usage is to use `interface` instead of `type` so tooling (such as tsc and refactoring tools) uses the type name instead of expanding it:

```typescript
export interface MyType extends Opaque<Brand<string, "myPackage.MyType">> {}
```

#### Signature {#opaque-signature}

```typescript
export declare type Opaque<T extends Brand<any, string>> = T extends Brand<
    infer ValueType,
    infer Name
>
    ? BrandedType<ValueType, Name>
    : never;
```

### PrimitiveValue {#primitivevalue-typealias}

#### Signature {#primitivevalue-signature}

```typescript
export declare type PrimitiveValue = string | boolean | number;
```

### RecursiveReadonly {#recursivereadonly-typealias}

Make all transitive properties in T readonly

#### Signature {#recursivereadonly-signature}

```typescript
export declare type RecursiveReadonly<T> = {
    readonly [P in keyof T]: RecursiveReadonly<T[P]>;
};
```

### RevisionTag {#revisiontag-typealias}

A way to refer to a particular revision within a given `Rebaser` instance.

#### Signature {#revisiontag-signature}

```typescript
export declare type RevisionTag = Brand<number, "rebaser.RevisionTag">;
```

### SeqNumber {#seqnumber-typealias}

#### Signature {#seqnumber-signature}

```typescript
export declare type SeqNumber = Brand<number, "edit-manager.SeqNumber">;
```

### SessionId {#sessionid-typealias}

#### Signature {#sessionid-signature}

```typescript
export declare type SessionId = string;
```

### SummaryElementParser {#summaryelementparser-typealias}

Parses a serialized/summarized string into an object, rehydrating any Fluid handles as necessary

#### Signature {#summaryelementparser-signature}

```typescript
export declare type SummaryElementParser = (contents: string) => unknown;
```

### SummaryElementStringifier {#summaryelementstringifier-typealias}

Serializes the given contents into a string acceptable for storing in summaries, i.e. all Fluid handles have been replaced appropriately by an IFluidSerializer

#### Signature {#summaryelementstringifier-signature}

```typescript
export declare type SummaryElementStringifier = (contents: unknown) => string;
```

### ToDelta {#todelta-typealias}

The `index` represents the index of the child node in the input context. The `index` should be `undefined` iff the child node does not exist in the input context (e.g., an inserted node).

#### Signature {#todelta-signature}

```typescript
export declare type ToDelta = (child: NodeChangeset, index: number | undefined) => Delta.Modify;
```

### TreeSchemaIdentifier {#treeschemaidentifier-typealias}

SchemaIdentifier for a Tree. Also known as "Definition"

#### Signature {#treeschemaidentifier-signature}

```typescript
export declare type TreeSchemaIdentifier = Brand<string, "tree.TreeSchemaIdentifier">;
```

### TreeType {#treetype-typealias}

#### Signature {#treetype-signature}

```typescript
export declare type TreeType = TreeSchemaIdentifier;
```

### TreeTypeSet {#treetypeset-typealias}

Set of allowed tree types. Providing multiple values here allows polymorphism, tagged union style.

If not specified, types are unconstrained (equivalent to the set containing every TreeSchemaIdentifier defined in the document).

Note that even when unconstrained, children must still be in-schema for their own type.

In the future, this could be extended to allow inlining a TreeSchema here (or some similar structural schema system). For structural types which could go here, there are a few interesting options:

-   Allow replacing the whole set with a structural type for terminal / non-tree data, and use this as a replacement for values on the tree nodes.

-   Allow expression structural constraints for child trees, for example requiring specific traits (ex: via TreeSchema), instead of by type.

There are two ways this could work:

-   Constrain the child nodes based on their shape: this makes schema safe editing difficult because nodes would incur extra editing constraints to prevent them from going out of schema based on their location in such a field.

-   Constrain the types allowed based on which types guarantee their data will always meet the constraints.

Care would need to be taken to make sure this is sound for the schema updating mechanisms.

#### Signature {#treetypeset-signature}

```typescript
export declare type TreeTypeSet = ReadonlySet<TreeSchemaIdentifier> | undefined;
```

### UnwrappedEditableField {#unwrappededitablefield-typealias}

Unwrapped field. Non-sequence multiplicities are unwrapped to the child tree or `undefined` if there is none. Sequence multiplicities are handled with [EditableField](/docs/apis/tree/editablefield-interface)<!-- -->. See [UnwrappedEditableTree](/docs/apis/tree#unwrappededitabletree-typealias) for how the children themselves are unwrapped.

#### Signature {#unwrappededitablefield-signature}

```typescript
export declare type UnwrappedEditableField = UnwrappedEditableTree | undefined | EditableField;
```

### UnwrappedEditableTree {#unwrappededitabletree-typealias}

EditableTree, but with these cases of unwrapping: - primitives are unwrapped. See [EditableTreeOrPrimitive](/docs/apis/tree#editabletreeorprimitive-typealias)<!-- -->. - nodes with PrimaryField (see `getPrimaryField`<!-- -->) are unwrapped to [EditableField](/docs/apis/tree/editablefield-interface)<!-- -->s. - fields are unwrapped based on their schema's multiplicity. See [UnwrappedEditableField](/docs/apis/tree#unwrappededitablefield-typealias)<!-- -->.

#### Signature {#unwrappededitabletree-signature}

```typescript
export declare type UnwrappedEditableTree = EditableTreeOrPrimitive | EditableField;
```

### Value {#value-typealias}

Value stored on a node.

#### Signature {#value-signature}

```typescript
export declare type Value = undefined | TreeValue;
```

### ValueChange {#valuechange-typealias}

#### Signature {#valuechange-signature}

```typescript
export declare type ValueChange =
    | {
          revision?: RevisionTag;
          value?: Value;
      }
    | {
          revision?: RevisionTag;
          revert: RevisionTag | undefined;
      };
```

## Function Details

### allowsRepoSuperset {#allowsreposuperset-function}

#### Signature {#allowsreposuperset-signature}

```typescript
export declare function allowsRepoSuperset(
    policy: FullSchemaPolicy,
    original: SchemaData,
    superset: SchemaData,
): boolean;
```

#### Parameters {#allowsreposuperset-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        policy
      </td>
      <td>
        <a href='/docs/apis/tree/fullschemapolicy-interface'>FullSchemaPolicy</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        original
      </td>
      <td>
        <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        superset
      </td>
      <td>
        <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#allowsreposuperset-returns}

true iff `superset` is a superset of `original`<!-- -->.

This does not require a strict (aka proper) superset: equivalent schema will return true.

A version of this that assumes a specific root field could be slightly more permissive in some simple cases, however if any extra fields and fields with unconstrained types are reachable, it would have to compare everything anyway.

<b>Return type:</b> boolean

### applyModifyToTree {#applymodifytotree-function}

Converts inserted content into the format expected in Delta instances. This involves applying the following changes:

-   Updating node values

-   Inserting new subtrees within the inserted content

-   Deleting parts of the inserted content

The only kind of change that is not applied by this function is MoveIn.

#### Signature {#applymodifytotree-signature}

```typescript
export declare function applyModifyToTree(
    tree: MapTree,
    modify: Delta.Modify,
): Map<FieldKey, Delta.MarkList>;
```

#### Parameters {#applymodifytotree-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        tree
      </td>
      <td>
        <a href='/docs/apis/tree/maptree-interface'>MapTree</a>
      </td>
      <td>
        The subtree to apply modifications to. Updated in place.
      </td>
    </tr>
    <tr>
      <td>
        modify
      </td>
      <td>
        Delta.Modify
      </td>
      <td>
        The modifications to either apply or collect.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#applymodifytotree-returns}

The remaining modifications that the consumer of the Delta will apply on the given node. May be empty if all modifications are applied by the function.

<b>Return type:</b> Map&lt;[FieldKey](/docs/apis/tree#fieldkey-typealias)<!-- -->, Delta.MarkList&gt;

### buildForest {#buildforest-function}

#### Signature {#buildforest-signature}

```typescript
export declare function buildForest(
    schema: StoredSchemaRepository,
    anchors?: AnchorSet,
): IEditableForest;
```

#### Parameters {#buildforest-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        schema
      </td>
      <td>
      </td>
      <td>
        <a href='/docs/apis/tree/storedschemarepository-interface'>StoredSchemaRepository</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        anchors
      </td>
      <td>
        optional
      </td>
      <td>
        <a href='/docs/apis/tree/anchorset-class'>AnchorSet</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#buildforest-returns}

an implementation of [IEditableForest](/docs/apis/tree/ieditableforest-interface) with no data or schema.

<b>Return type:</b> [IEditableForest](/docs/apis/tree/ieditableforest-interface)

### cachedValue {#cachedvalue-function}

Create a ICachedValue that is invalidated when `observer` (as provided to `compute`<!-- -->) gets invalidated.

#### Signature {#cachedvalue-signature}

```typescript
export declare function cachedValue<T>(
    compute: (observer: ObservingDependent) => T,
    computationName?: string,
): ICachedValue<T>;
```

#### Parameters {#cachedvalue-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        compute
      </td>
      <td>
      </td>
      <td>
        (observer: <a href='/docs/apis/tree/observingdependent-interface'>ObservingDependent</a>) => T
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        computationName
      </td>
      <td>
        optional
      </td>
      <td>
        string
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#cachedvalue-returns}

<b>Return type:</b> [ICachedValue](/docs/apis/tree/icachedvalue-interface)<!-- -->&lt;T&gt;

### clonePath {#clonepath-function}

#### Signature {#clonepath-signature}

```typescript
export declare function clonePath(path: UpPath): UpPath;
```

#### Parameters {#clonepath-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        path
      </td>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#clonepath-returns}

a deep copy of the provided path as simple javascript objects. This is safe to hold onto and use deep object comparisons on.

<b>Return type:</b> [UpPath](/docs/apis/tree/uppath-interface)

### clonePath {#clonepath_1-function}

#### Signature {#clonepath_1-signature}

```typescript
export declare function clonePath(path: UpPath | undefined): UpPath | undefined;
```

#### Parameters {#clonepath_1-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        path
      </td>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a> | undefined
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#clonepath_1-returns}

a deep copy of the provided path as simple javascript objects. This is safe to hold onto and use deep object comparisons on.

<b>Return type:</b> [UpPath](/docs/apis/tree/uppath-interface) \| undefined

### commitEncoderFromChangeEncoder {#commitencoderfromchangeencoder-function}

#### Signature {#commitencoderfromchangeencoder-signature}

```typescript
export declare function commitEncoderFromChangeEncoder<TChangeset>(
    changeEncoder: ChangeEncoder<TChangeset>,
): CommitEncoder<TChangeset>;
```

#### Parameters {#commitencoderfromchangeencoder-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        changeEncoder
      </td>
      <td>
        <a href='/docs/apis/tree/changeencoder-class'>ChangeEncoder</a><TChangeset>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#commitencoderfromchangeencoder-returns}

<b>Return type:</b> [CommitEncoder](/docs/apis/tree/commitencoder-interface)<!-- -->&lt;TChangeset&gt;

### compareFieldUpPaths {#comparefielduppaths-function}

#### Signature {#comparefielduppaths-signature}

```typescript
export declare function compareFieldUpPaths(a: FieldUpPath, b: FieldUpPath): boolean;
```

#### Parameters {#comparefielduppaths-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        a
      </td>
      <td>
        <a href='/docs/apis/tree/fielduppath-interface'>FieldUpPath</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        b
      </td>
      <td>
        <a href='/docs/apis/tree/fielduppath-interface'>FieldUpPath</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#comparefielduppaths-returns}

true iff `a` and `b` describe the same field path.

Note that for mutable paths (as used in `AnchorSet`<!-- -->), this equality may change over time: this only checks if the two paths are currently the same.

<b>Return type:</b> boolean

### compareUpPaths {#compareuppaths-function}

#### Signature {#compareuppaths-signature}

```typescript
export declare function compareUpPaths(a: UpPath | undefined, b: UpPath | undefined): boolean;
```

#### Parameters {#compareuppaths-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        a
      </td>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a> | undefined
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        b
      </td>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a> | undefined
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#compareuppaths-returns}

true iff `a` and `b` describe the same path.

Note that for mutable paths (as used in `AnchorSet`<!-- -->), this equality may change over time: this only checks if the two paths are currently the same.

<b>Return type:</b> boolean

### cursorToJsonObject {#cursortojsonobject-function}

Extract a JS object tree from the contents of the given ITreeCursor. Assumes that ITreeCursor contains only unaugmented JsonTypes.

#### Signature {#cursortojsonobject-signature}

```typescript
export declare function cursorToJsonObject(reader: ITreeCursor): JsonCompatible;
```

#### Parameters {#cursortojsonobject-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        reader
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#cursortojsonobject-returns}

<b>Return type:</b> [JsonCompatible](/docs/apis/tree#jsoncompatible-typealias)

### detachedFieldAsKey {#detachedfieldaskey-function}

Some code abstracts the root as a node with detached fields as its fields. This maps detached field to field keys for thus use.

#### Signature {#detachedfieldaskey-signature}

```typescript
export declare function detachedFieldAsKey(field: DetachedField): FieldKey;
```

#### Parameters {#detachedfieldaskey-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        field
      </td>
      <td>
        <a href='/docs/apis/tree/detachedfield-interface'>DetachedField</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#detachedfieldaskey-returns}

`field` as a [FieldKey](/docs/apis/tree#fieldkey-typealias) usable on a special root node serving as a parent of detached fields.

<b>Return type:</b> [FieldKey](/docs/apis/tree#fieldkey-typealias)

### encodeSummary {#encodesummary-function}

#### Signature {#encodesummary-signature}

```typescript
export declare function stringifySummary<TChange>(
    data: ReadonlySummaryData<TChange>,
    encoder: CommitEncoder<TChange>,
): string;
```

#### Parameters {#encodesummary-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree/readonlysummarydata-interface'>ReadonlySummaryData</a><TChange>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        encoder
      </td>
      <td>
        <a href='/docs/apis/tree/commitencoder-interface'>CommitEncoder</a><TChange>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#encodesummary-returns}

<b>Return type:</b> string

### extractFromOpaque {#extractfromopaque-function}

Converts a [Opaque](/docs/apis/tree#opaque-typealias) handle to the underlying branded type.

It is assumed that only code that produces these "opaque" handles does this conversion, allowing these handles to be considered opaque.

#### Signature {#extractfromopaque-signature}

```typescript
export declare function extractFromOpaque<TOpaque extends BrandedType<any, string>>(
    value: TOpaque,
): ExtractFromOpaque<TOpaque>;
```

#### Parameters {#extractfromopaque-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        value
      </td>
      <td>
        TOpaque
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#extractfromopaque-returns}

<b>Return type:</b> [ExtractFromOpaque](/docs/apis/tree#extractfromopaque-typealias)<!-- -->&lt;TOpaque&gt;

### fieldSchema {#fieldschema-function}

Helper for building [FieldSchema](/docs/apis/tree/fieldschema-interface)<!-- -->.

#### Signature {#fieldschema-signature}

```typescript
export declare function fieldSchema(
    kind: {
        identifier: FieldKindIdentifier;
    },
    types?: Iterable<TreeSchemaIdentifier>,
): FieldSchema;
```

#### Parameters {#fieldschema-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        kind
      </td>
      <td>
      </td>
      <td>
        { identifier: <a href='/docs/apis/tree#fieldkindidentifier-typealias'>FieldKindIdentifier</a>; }
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        types
      </td>
      <td>
        optional
      </td>
      <td>
        Iterable<<a href='/docs/apis/tree#treeschemaidentifier-typealias'>TreeSchemaIdentifier</a>>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#fieldschema-returns}

<b>Return type:</b> [FieldSchema](/docs/apis/tree/fieldschema-interface)

### forEachField {#foreachfield-function}

#### Signature {#foreachfield-signature}

```typescript
export declare function forEachField<TCursor extends ITreeCursor = ITreeCursor>(
    cursor: TCursor,
    f: (cursor: TCursor) => void,
): void;
```

#### Parameters {#foreachfield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        cursor
      </td>
      <td>
        TCursor
      </td>
      <td>
        cursor at a node whose fields will be visited.
      </td>
    </tr>
    <tr>
      <td>
        f
      </td>
      <td>
        (cursor: TCursor) => void
      </td>
      <td>
        For on each field. If <code>f</code> moves cursor, it must put it back to where it was at the beginning of <code>f</code> before returning.
      </td>
    </tr>
  </tbody>
</table>

### forEachNode {#foreachnode-function}

#### Signature {#foreachnode-signature}

```typescript
export declare function forEachNode<TCursor extends ITreeCursor = ITreeCursor>(
    cursor: TCursor,
    f: (cursor: TCursor) => void,
): void;
```

#### Parameters {#foreachnode-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        cursor
      </td>
      <td>
        TCursor
      </td>
      <td>
        cursor at a field whose nodes will be visited.
      </td>
    </tr>
    <tr>
      <td>
        f
      </td>
      <td>
        (cursor: TCursor) => void
      </td>
      <td>
        For on each node. If <code>f</code> moves cursor, it must put it back to where it was at the beginning of <code>f</code> before returning.
      </td>
    </tr>
  </tbody>
</table>

### genericTreeDeleteIfEmpty {#generictreedeleteifempty-function}

Delete a field if empty. Optionally delete FieldMapObject if empty as well.

#### Signature {#generictreedeleteifempty-signature}

```typescript
export declare function genericTreeDeleteIfEmpty<T>(
    node: GenericFieldsNode<T>,
    key: FieldKey,
    removeMapObject: boolean,
): void;
```

#### Parameters {#generictreedeleteifempty-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        node
      </td>
      <td>
        <a href='/docs/apis/tree/genericfieldsnode-interface'>GenericFieldsNode</a><T>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        removeMapObject
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

### genericTreeKeys {#generictreekeys-function}

#### Signature {#generictreekeys-signature}

```typescript
export declare function genericTreeKeys<T>(tree: GenericFieldsNode<T>): readonly FieldKey[];
```

#### Parameters {#generictreekeys-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        tree
      </td>
      <td>
        <a href='/docs/apis/tree/genericfieldsnode-interface'>GenericFieldsNode</a><T>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#generictreekeys-returns}

keys for fields of `tree`<!-- -->.

<b>Return type:</b> readonly [FieldKey](/docs/apis/tree#fieldkey-typealias)<!-- -->\[\]

### getDepth {#getdepth-function}

#### Signature {#getdepth-signature}

```typescript
export declare function getDepth(path: UpPath): number;
```

#### Parameters {#getdepth-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        path
      </td>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#getdepth-returns}

the number of nodes above this one. Zero when the path's parent is undefined, meaning the path represents a node in a detached field. Runs in O(depth) time.

<b>Return type:</b> number

### getDescendant {#getdescendant-function}

#### Signature {#getdescendant-signature}

```typescript
export declare function getDescendant<TData>(
    ancestor: SparseNode<TData>,
    path: UpPath | undefined,
): SparseNode<TData>;
```

#### Parameters {#getdescendant-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        ancestor
      </td>
      <td>
        <a href='/docs/apis/tree/sparsenode-class'>SparseNode</a><TData>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        path
      </td>
      <td>
        <a href='/docs/apis/tree/uppath-interface'>UpPath</a> | undefined
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#getdescendant-returns}

<b>Return type:</b> [SparseNode](/docs/apis/tree/sparsenode-class)<!-- -->&lt;TData&gt;

### getEditableTreeContext {#geteditabletreecontext-function}

A simple API for a Forest to interact with the tree.

#### Signature {#geteditabletreecontext-signature}

```typescript
export declare function getEditableTreeContext(
    forest: IEditableForest,
    transactionCheckout?: TransactionCheckout<DefaultEditBuilder, DefaultChangeset>,
): EditableTreeContext;
```

#### Parameters {#geteditabletreecontext-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        forest
      </td>
      <td>
      </td>
      <td>
        <a href='/docs/apis/tree/ieditableforest-interface'>IEditableForest</a>
      </td>
      <td>
        the Forest
      </td>
    </tr>
    <tr>
      <td>
        transactionCheckout
      </td>
      <td>
        optional
      </td>
      <td>
        <a href='/docs/apis/tree/checkout-interface'>TransactionCheckout</a><<a href='/docs/apis/tree/defaulteditbuilder-class'>DefaultEditBuilder</a>, <a href='/docs/apis/tree#defaultchangeset-typealias'>DefaultChangeset</a>>
      </td>
      <td>
        the Checkout applied to a transaction, not required in read-only usecases.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#geteditabletreecontext-returns}

[EditableTreeContext](/docs/apis/tree/editabletreecontext-interface) which is used to manage the cursors and anchors within the EditableTrees: This is necessary for supporting using this tree across edits to the forest, and not leaking memory.

<b>Return type:</b> [EditableTreeContext](/docs/apis/tree/editabletreecontext-interface)

### getGenericTreeField {#getgenerictreefield-function}

Get a field from `node`<!-- -->, optionally modifying the tree to create it if missing.

#### Signature {#getgenerictreefield-signature}

```typescript
export declare function getGenericTreeField<T>(
    node: GenericFieldsNode<T>,
    key: FieldKey,
    createIfMissing: boolean,
): T[];
```

#### Parameters {#getgenerictreefield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        node
      </td>
      <td>
        <a href='/docs/apis/tree/genericfieldsnode-interface'>GenericFieldsNode</a><T>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        createIfMissing
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#getgenerictreefield-returns}

<b>Return type:</b> T\[\]

### getMapTreeField {#getmaptreefield-function}

Get a field from `node`<!-- -->, optionally modifying the tree to create it if missing.

#### Signature {#getmaptreefield-signature}

```typescript
export declare function getMapTreeField(
    node: MapTree,
    key: FieldKey,
    createIfMissing: boolean,
): MapTree[];
```

#### Parameters {#getmaptreefield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        node
      </td>
      <td>
        <a href='/docs/apis/tree/maptree-interface'>MapTree</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        createIfMissing
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#getmaptreefield-returns}

<b>Return type:</b> [MapTree](/docs/apis/tree/maptree-interface)<!-- -->\[\]

### getPrimaryField {#getprimaryfield-function}

#### Signature {#getprimaryfield-signature}

```typescript
export declare function getPrimaryField(schema: TreeSchema):
    | {
          key: LocalFieldKey;
          schema: FieldSchema;
      }
    | undefined;
```

#### Parameters {#getprimaryfield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        schema
      </td>
      <td>
        <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#getprimaryfield-returns}

the key and the schema of the primary field out of the given tree schema.

See note on [EmptyKey](/docs/apis/tree#emptykey-variable) for what is a primary field.

<b>Return type:</b> { key: [LocalFieldKey](/docs/apis/tree#localfieldkey-typealias)<!-- -->; schema: [FieldSchema](/docs/apis/tree/fieldschema-interface)<!-- -->; } \| undefined

### getSchemaString {#getschemastring-function}

Synchronous monolithic summarization of schema content.

TODO: when perf matters, this should be replaced with a chunked async version using a binary format.

#### Signature {#getschemastring-signature}

```typescript
export declare function getSchemaString(data: SchemaData): string;
```

#### Parameters {#getschemastring-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#getschemastring-returns}

a snapshot of the schema as a string.

<b>Return type:</b> string

### initializeForest {#initializeforest-function}

#### Signature {#initializeforest-signature}

```typescript
export declare function initializeForest(
    forest: IEditableForest,
    content: ITreeCursorSynchronous[],
): void;
```

#### Parameters {#initializeforest-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        forest
      </td>
      <td>
        <a href='/docs/apis/tree/ieditableforest-interface'>IEditableForest</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        content
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursorsynchronous-interface'>ITreeCursorSynchronous</a>[]
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

### isContextuallyTypedNodeDataObject {#iscontextuallytypednodedataobject-function}

Checks the type of a `ContextuallyTypedNodeData`<!-- -->.

#### Signature {#iscontextuallytypednodedataobject-signature}

```typescript
export declare function isContextuallyTypedNodeDataObject(
    data: ContextuallyTypedNodeData | undefined,
): data is ContextuallyTypedNodeDataObject;
```

#### Parameters {#iscontextuallytypednodedataobject-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a> | undefined
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#iscontextuallytypednodedataobject-returns}

<b>Return type:</b> data is [ContextuallyTypedNodeDataObject](/docs/apis/tree/contextuallytypednodedataobject-interface)

### isEditableField {#iseditablefield-function}

Checks the type of an UnwrappedEditableField.

#### Signature {#iseditablefield-signature}

```typescript
export declare function isEditableField(field: UnwrappedEditableField): field is EditableField;
```

#### Parameters {#iseditablefield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        field
      </td>
      <td>
        <a href='/docs/apis/tree#unwrappededitablefield-typealias'>UnwrappedEditableField</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#iseditablefield-returns}

<b>Return type:</b> field is [EditableField](/docs/apis/tree/editablefield-interface)

### isFieldLocation {#isfieldlocation-function}

#### Signature {#isfieldlocation-signature}

```typescript
export declare function isFieldLocation(
    range: FieldLocation | DetachedField,
): range is FieldLocation;
```

#### Parameters {#isfieldlocation-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        range
      </td>
      <td>
        <a href='/docs/apis/tree/fieldlocation-interface'>FieldLocation</a> | <a href='/docs/apis/tree/detachedfield-interface'>DetachedField</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isfieldlocation-returns}

<b>Return type:</b> range is [FieldLocation](/docs/apis/tree/fieldlocation-interface)

### isGlobalFieldKey {#isglobalfieldkey-function}

Derives the scope using the type of `key`<!-- -->.

#### Signature {#isglobalfieldkey-signature}

```typescript
export declare function isGlobalFieldKey(key: FieldKey): key is GlobalFieldKeySymbol;
```

#### Parameters {#isglobalfieldkey-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isglobalfieldkey-returns}

<b>Return type:</b> key is [GlobalFieldKeySymbol](/docs/apis/tree#globalfieldkeysymbol-typealias)

### isLocalKey {#islocalkey-function}

#### Signature {#islocalkey-signature}

```typescript
export declare function isLocalKey(key: FieldKey): key is LocalFieldKey;
```

#### Parameters {#islocalkey-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#islocalkey-returns}

<b>Return type:</b> key is [LocalFieldKey](/docs/apis/tree#localfieldkey-typealias)

### isNeverField {#isneverfield-function}

#### Signature {#isneverfield-signature}

```typescript
export declare function isNeverField(
    policy: FullSchemaPolicy,
    originalData: SchemaData,
    field: FieldSchema,
): boolean;
```

#### Parameters {#isneverfield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        policy
      </td>
      <td>
        <a href='/docs/apis/tree/fullschemapolicy-interface'>FullSchemaPolicy</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        originalData
      </td>
      <td>
        <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        field
      </td>
      <td>
        <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isneverfield-returns}

<b>Return type:</b> boolean

### isPrimitive {#isprimitive-function}

#### Signature {#isprimitive-signature}

```typescript
export declare function isPrimitive(schema: TreeSchema): boolean;
```

#### Parameters {#isprimitive-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        schema
      </td>
      <td>
        <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isprimitive-returns}

true iff `schema` trees should default to being viewed as just their value when possible.

Note that this may return true for some types which can not be unwrapped to just their value, since EditableTree avoids ever unwrapping primitives that are objects so users checking for primitives by type won't be broken. Checking for this object case is done elsewhere.

<b>Return type:</b> boolean

### isPrimitiveValue {#isprimitivevalue-function}

#### Signature {#isprimitivevalue-signature}

```typescript
export declare function isPrimitiveValue(nodeValue: Value): nodeValue is PrimitiveValue;
```

#### Parameters {#isprimitivevalue-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        nodeValue
      </td>
      <td>
        <a href='/docs/apis/tree#value-typealias'>Value</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isprimitivevalue-returns}

<b>Return type:</b> nodeValue is [PrimitiveValue](/docs/apis/tree#primitivevalue-typealias)

### isUnwrappedNode {#isunwrappednode-function}

Checks the type of an UnwrappedEditableField.

#### Signature {#isunwrappednode-signature}

```typescript
export declare function isUnwrappedNode(field: UnwrappedEditableField): field is EditableTree;
```

#### Parameters {#isunwrappednode-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        field
      </td>
      <td>
        <a href='/docs/apis/tree#unwrappededitablefield-typealias'>UnwrappedEditableField</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#isunwrappednode-returns}

<b>Return type:</b> field is [EditableTree](/docs/apis/tree/editabletree-interface)

### isWritableArrayLike {#iswritablearraylike-function}

Checks the type of a `ContextuallyTypedNodeData`<!-- -->.

#### Signature {#iswritablearraylike-signature}

```typescript
export declare function isWritableArrayLike(
    data: ContextuallyTypedNodeData | undefined,
): data is MarkedArrayLike<ContextuallyTypedNodeData>;
```

#### Parameters {#iswritablearraylike-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree#contextuallytypednodedata-typealias'>ContextuallyTypedNodeData</a> | undefined
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#iswritablearraylike-returns}

<b>Return type:</b> data is [MarkedArrayLike](/docs/apis/tree/markedarraylike-interface)<!-- -->&lt;[ContextuallyTypedNodeData](/docs/apis/tree#contextuallytypednodedata-typealias)<!-- -->&gt;

### jsonableTreeFromCursor {#jsonabletreefromcursor-function}

Extract a JsonableTree from the contents of the given ITreeCursor's current node.

#### Signature {#jsonabletreefromcursor-signature}

```typescript
export declare function jsonableTreeFromCursor(cursor: ITreeCursor): JsonableTree;
```

#### Parameters {#jsonabletreefromcursor-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        cursor
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#jsonabletreefromcursor-returns}

<b>Return type:</b> [JsonableTree](/docs/apis/tree/jsonabletree-interface)

### keyAsDetachedField {#keyasdetachedfield-function}

The inverse of [detachedFieldAsKey()](/docs/apis/tree#detachedfieldaskey-function)<!-- -->. Thus must only be used on [LocalFieldKey](/docs/apis/tree#localfieldkey-typealias)<!-- -->s which were produced via [detachedFieldAsKey()](/docs/apis/tree#detachedfieldaskey-function)<!-- -->, and with the same scope (ex: forest) as the detachedFieldAsKey was originally from.

#### Signature {#keyasdetachedfield-signature}

```typescript
export declare function keyAsDetachedField(key: FieldKey): DetachedField;
```

#### Parameters {#keyasdetachedfield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#keyasdetachedfield-returns}

<b>Return type:</b> [DetachedField](/docs/apis/tree/detachedfield-interface)

### keyFromSymbol {#keyfromsymbol-function}

#### Signature {#keyfromsymbol-signature}

```typescript
export declare function keyFromSymbol(key: GlobalFieldKeySymbol): GlobalFieldKey;
```

#### Parameters {#keyfromsymbol-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#globalfieldkeysymbol-typealias'>GlobalFieldKeySymbol</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#keyfromsymbol-returns}

the original [GlobalFieldKey](/docs/apis/tree#globalfieldkey-typealias) for the symbol.

<b>Return type:</b> [GlobalFieldKey](/docs/apis/tree#globalfieldkey-typealias)

### loadSummary {#loadsummary-function}

#### Signature {#loadsummary-signature}

```typescript
export declare function parseSummary<TChange>(
    summary: string,
    encoder: CommitEncoder<TChange>,
    destination: MutableSummaryData<TChange>,
): void;
```

#### Parameters {#loadsummary-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        summary
      </td>
      <td>
        string
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        encoder
      </td>
      <td>
        <a href='/docs/apis/tree/commitencoder-interface'>CommitEncoder</a><TChange>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        destination
      </td>
      <td>
        <a href='/docs/apis/tree/mutablesummarydata-interface'>MutableSummaryData</a><TChange>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

### lookupGlobalFieldSchema {#lookupglobalfieldschema-function}

#### Signature {#lookupglobalfieldschema-signature}

```typescript
export declare function lookupGlobalFieldSchema(
    data: SchemaDataAndPolicy,
    identifier: GlobalFieldKey,
): FieldSchema;
```

#### Parameters {#lookupglobalfieldschema-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree/schemadataandpolicy-interface'>SchemaDataAndPolicy</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        identifier
      </td>
      <td>
        <a href='/docs/apis/tree#globalfieldkey-typealias'>GlobalFieldKey</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#lookupglobalfieldschema-returns}

<b>Return type:</b> [FieldSchema](/docs/apis/tree/fieldschema-interface)

### lookupTreeSchema {#lookuptreeschema-function}

#### Signature {#lookuptreeschema-signature}

```typescript
export declare function lookupTreeSchema(
    data: SchemaDataAndPolicy,
    identifier: TreeSchemaIdentifier,
): TreeSchema;
```

#### Parameters {#lookuptreeschema-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree/schemadataandpolicy-interface'>SchemaDataAndPolicy</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        identifier
      </td>
      <td>
        <a href='/docs/apis/tree#treeschemaidentifier-typealias'>TreeSchemaIdentifier</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#lookuptreeschema-returns}

<b>Return type:</b> [TreeSchema](/docs/apis/tree/treeschema-interface)

### makeAnonChange {#makeanonchange-function}

#### Signature {#makeanonchange-signature}

```typescript
export declare function makeAnonChange<T>(change: T): TaggedChange<T>;
```

#### Parameters {#makeanonchange-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        change
      </td>
      <td>
        T
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#makeanonchange-returns}

<b>Return type:</b> [TaggedChange](/docs/apis/tree/taggedchange-interface)<!-- -->&lt;T&gt;

### mapCursorField {#mapcursorfield-function}

#### Signature {#mapcursorfield-signature}

```typescript
export declare function mapCursorField<T, TCursor extends ITreeCursor = ITreeCursor>(
    cursor: TCursor,
    f: (cursor: TCursor) => T,
): T[];
```

#### Parameters {#mapcursorfield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        cursor
      </td>
      <td>
        TCursor
      </td>
      <td>
        tree whose field will be visited.
      </td>
    </tr>
    <tr>
      <td>
        f
      </td>
      <td>
        (cursor: TCursor) => T
      </td>
      <td>
        builds output from field member, which will be selected in cursor when cursor is provided. If <code>f</code> moves cursor, it must put it back to where it was at the beginning of <code>f</code> before returning.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#mapcursorfield-returns}

array resulting from applying `f` to each item of the current field on `cursor`<!-- -->. Returns an empty array if the field is empty or not present (which are considered the same).

<b>Return type:</b> T\[\]

### mapCursorFields {#mapcursorfields-function}

#### Signature {#mapcursorfields-signature}

```typescript
export declare function mapCursorFields<T, TCursor extends ITreeCursor = ITreeCursor>(
    cursor: TCursor,
    f: (cursor: TCursor) => T,
): T[];
```

#### Parameters {#mapcursorfields-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        cursor
      </td>
      <td>
        TCursor
      </td>
      <td>
        tree whose fields will be visited.
      </td>
    </tr>
    <tr>
      <td>
        f
      </td>
      <td>
        (cursor: TCursor) => T
      </td>
      <td>
        builds output from field, which will be selected in cursor when cursor is provided. If <code>f</code> moves cursor, it must put it back to where it was at the beginning of <code>f</code> before returning.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#mapcursorfields-returns}

array resulting from applying `f` to each field of the current node on `cursor`<!-- -->. Returns an empty array if the node is empty or not present (which are considered the same). Note that order is not specified for field iteration.

<b>Return type:</b> T\[\]

### mapFieldMarks {#mapfieldmarks-function}

Converts a `Delta.FieldMarks` whose tree content is represented with by `TIn` instances into a `Delta.FieldMarks`<!-- -->whose tree content is represented with by `TOut` instances.

This function is useful for converting `Delta`<!-- -->s that represent tree content with cursors into `Delta`<!-- -->s that represent tree content with a deep-comparable representation of the content. See assertDeltaEqual. TODO: link this

#### Signature {#mapfieldmarks-signature}

```typescript
export declare function mapFieldMarks<TIn, TOut>(
    fields: Delta.FieldMarks<TIn>,
    func: (tree: TIn) => TOut,
): Delta.FieldMarks<TOut>;
```

#### Parameters {#mapfieldmarks-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        fields
      </td>
      <td>
        Delta.FieldMarks<TIn>
      </td>
      <td>
        The Map of fields to convert. Not mutated.
      </td>
    </tr>
    <tr>
      <td>
        func
      </td>
      <td>
        (tree: TIn) => TOut
      </td>
      <td>
        The functions used to map tree content.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#mapfieldmarks-returns}

<b>Return type:</b> Delta.FieldMarks&lt;TOut&gt;

### mapFromNamed {#mapfromnamed-function}

#### Signature {#mapfromnamed-signature}

```typescript
export declare function mapFromNamed<T extends Named<TName>, TName>(
    named: Iterable<T>,
): Map<TName, T>;
```

#### Parameters {#mapfromnamed-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        named
      </td>
      <td>
        Iterable<T>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#mapfromnamed-returns}

a map from name of item with that name from a collection of named items.

<b>Return type:</b> Map&lt;TName, T&gt;

### mapMark {#mapmark-function}

Converts a `Delta.Mark` whose tree content is represented with by `TIn` instances into a `Delta.Mark`<!-- -->whose tree content is represented with by `TOut` instances.

This function is useful for converting `Delta`<!-- -->s that represent tree content with cursors into `Delta`<!-- -->s that represent tree content with a deep-comparable representation of the content. See assertMarkListEqual. TODO: link this

#### Signature {#mapmark-signature}

```typescript
export declare function mapMark<TIn, TOut>(
    mark: Delta.Mark<TIn>,
    func: (tree: TIn) => TOut,
): Delta.Mark<TOut>;
```

#### Parameters {#mapmark-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        mark
      </td>
      <td>
        Delta.Mark<TIn>
      </td>
      <td>
        The mark to convert. Not mutated.
      </td>
    </tr>
    <tr>
      <td>
        func
      </td>
      <td>
        (tree: TIn) => TOut
      </td>
      <td>
        The functions used to map tree content.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#mapmark-returns}

<b>Return type:</b> Delta.Mark&lt;TOut&gt;

### mapMarkList {#mapmarklist-function}

Converts a `Delta.MarkList` whose tree content is represented with by `TIn` instances into a `Delta.MarkList`<!-- -->whose tree content is represented with by `TOut` instances.

This function is useful for converting `Delta`<!-- -->s that represent tree content with cursors into `Delta`<!-- -->s that represent tree content with a deep-comparable representation of the content. See assertMarkListEqual. TODO: link this

#### Signature {#mapmarklist-signature}

```typescript
export declare function mapMarkList<TIn, TOut>(
    list: Delta.MarkList<TIn>,
    func: (tree: TIn) => TOut,
): Delta.MarkList<TOut>;
```

#### Parameters {#mapmarklist-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        list
      </td>
      <td>
        Delta.MarkList<TIn>
      </td>
      <td>
        The list of marks to convert. Not mutated.
      </td>
    </tr>
    <tr>
      <td>
        func
      </td>
      <td>
        (tree: TIn) => TOut
      </td>
      <td>
        The functions used to map tree content.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#mapmarklist-returns}

<b>Return type:</b> Delta.MarkList&lt;TOut&gt;

### mapTreeFromCursor {#maptreefromcursor-function}

Extract a MapTree from the contents of the given ITreeCursor's current node.

#### Signature {#maptreefromcursor-signature}

```typescript
export declare function mapTreeFromCursor(cursor: ITreeCursor): MapTree;
```

#### Parameters {#maptreefromcursor-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        cursor
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#maptreefromcursor-returns}

<b>Return type:</b> [MapTree](/docs/apis/tree/maptree-interface)

### moveToDetachedField {#movetodetachedfield-function}

#### Signature {#movetodetachedfield-signature}

```typescript
export declare function moveToDetachedField(
    forest: IForestSubscription,
    cursorToMove: ITreeSubscriptionCursor,
    field?: DetachedField,
): void;
```

#### Parameters {#movetodetachedfield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        forest
      </td>
      <td>
      </td>
      <td>
        <a href='/docs/apis/tree/iforestsubscription-interface'>IForestSubscription</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        cursorToMove
      </td>
      <td>
      </td>
      <td>
        <a href='/docs/apis/tree/itreesubscriptioncursor-interface'>ITreeSubscriptionCursor</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        field
      </td>
      <td>
        optional
      </td>
      <td>
        <a href='/docs/apis/tree/detachedfield-interface'>DetachedField</a>
      </td>
      <td>
        defaults to <a href='/docs/apis/tree#rootfield-variable'>rootField</a>.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#movetodetachedfield-returns}

anchor to `field`<!-- -->.

### namedTreeSchema {#namedtreeschema-function}

Helper for building [NamedTreeSchema](/docs/apis/tree#namedtreeschema-typealias)<!-- -->.

#### Signature {#namedtreeschema-signature}

```typescript
export declare function namedTreeSchema(
    data: Partial<TreeSchemaBuilder> & Named<TreeSchemaIdentifier>,
): NamedTreeSchema;
```

#### Parameters {#namedtreeschema-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        Partial<<a href='/docs/apis/tree/treeschemabuilder-interface'>TreeSchemaBuilder</a>> & <a href='/docs/apis/tree/named-interface'>Named</a><<a href='/docs/apis/tree#treeschemaidentifier-typealias'>TreeSchemaIdentifier</a>>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#namedtreeschema-returns}

<b>Return type:</b> [NamedTreeSchema](/docs/apis/tree#namedtreeschema-typealias)

### recordDependency {#recorddependency-function}

Ensures this context's computation is a dependant to dependee (adding it if needed). Ensures this context's computation has dependee as a dependee (adding it if needed).

#### Signature {#recorddependency-signature}

```typescript
export declare function recordDependency(
    dependent: ObservingDependent | undefined,
    dependee: Dependee,
): void;
```

#### Parameters {#recorddependency-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        dependent
      </td>
      <td>
        <a href='/docs/apis/tree/observingdependent-interface'>ObservingDependent</a> | undefined
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        dependee
      </td>
      <td>
        <a href='/docs/apis/tree/dependee-interface'>Dependee</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

### runSynchronousTransaction {#runsynchronoustransaction-function}

#### Signature {#runsynchronoustransaction-signature}

```typescript
export declare function runSynchronousTransaction<
    TEditor extends ProgressiveEditBuilder<TChange>,
    TChange,
>(
    { forest, changeFamily, submitEdit }: Checkout<TEditor, TChange>,
    command: (forest: IForestSubscription, editor: TEditor) => TransactionResult,
): TransactionResult;
```

#### Parameters {#runsynchronoustransaction-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        { forest, changeFamily, submitEdit }
      </td>
      <td>
        <a href='/docs/apis/tree/checkout-interface'>Checkout</a><TEditor, TChange>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        command
      </td>
      <td>
        (forest: <a href='/docs/apis/tree/iforestsubscription-interface'>IForestSubscription</a>, editor: TEditor) => <a href='/docs/apis/tree#transactionresult-enum'>TransactionResult</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#runsynchronoustransaction-returns}

<b>Return type:</b> [TransactionResult](/docs/apis/tree#transactionresult-enum)

### schemaDataIsEmpty {#schemadataisempty-function}

#### Signature {#schemadataisempty-signature}

```typescript
export declare function schemaDataIsEmpty(data: SchemaData): boolean;
```

#### Parameters {#schemadataisempty-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#schemadataisempty-returns}

<b>Return type:</b> boolean

### scopeFromKey {#scopefromkey-function}

Derives the scope using the type of `key`<!-- -->.

#### Signature {#scopefromkey-signature}

```typescript
export declare function scopeFromKey(key: FieldKey): [FieldScope, LocalFieldKey | GlobalFieldKey];
```

#### Parameters {#scopefromkey-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#scopefromkey-returns}

<b>Return type:</b> \[[FieldScope](/docs/apis/tree#fieldscope-enum)<!-- -->, [LocalFieldKey](/docs/apis/tree#localfieldkey-typealias) \| [GlobalFieldKey](/docs/apis/tree#globalfieldkey-typealias)<!-- -->\]

### setGenericTreeField {#setgenerictreefield-function}

Sets a field on `node`<!-- -->.

#### Signature {#setgenerictreefield-signature}

```typescript
export declare function setGenericTreeField<T>(
    node: GenericFieldsNode<T>,
    key: FieldKey,
    content: T[],
): void;
```

#### Parameters {#setgenerictreefield-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        node
      </td>
      <td>
        <a href='/docs/apis/tree/genericfieldsnode-interface'>GenericFieldsNode</a><T>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        content
      </td>
      <td>
        T[]
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

### singleJsonCursor {#singlejsoncursor-function}

Used to read a Jsonable tree for testing and benchmarking.

#### Signature {#singlejsoncursor-signature}

```typescript
export declare function singleJsonCursor(root: JsonCompatible): ITreeCursorSynchronous;
```

#### Parameters {#singlejsoncursor-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        root
      </td>
      <td>
        <a href='/docs/apis/tree#jsoncompatible-typealias'>JsonCompatible</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#singlejsoncursor-returns}

an [ITreeCursorSynchronous](/docs/apis/tree/itreecursorsynchronous-interface) for a single [JsonCompatible](/docs/apis/tree#jsoncompatible-typealias)<!-- -->.

<b>Return type:</b> [ITreeCursorSynchronous](/docs/apis/tree/itreecursorsynchronous-interface)

### singleMapTreeCursor {#singlemaptreecursor-function}

#### Signature {#singlemaptreecursor-signature}

```typescript
export declare function singleMapTreeCursor(root: MapTree): CursorWithNode<MapTree>;
```

#### Parameters {#singlemaptreecursor-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        root
      </td>
      <td>
        <a href='/docs/apis/tree/maptree-interface'>MapTree</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#singlemaptreecursor-returns}

an ITreeCursorSynchronous for a single MapTree.

<b>Return type:</b> [CursorWithNode](/docs/apis/tree/cursorwithnode-interface)<!-- -->&lt;[MapTree](/docs/apis/tree/maptree-interface)<!-- -->&gt;

### singleStackTreeCursor {#singlestacktreecursor-function}

#### Signature {#singlestacktreecursor-signature}

```typescript
export declare function singleStackTreeCursor<TNode>(
    root: TNode,
    adapter: CursorAdapter<TNode>,
): CursorWithNode<TNode>;
```

#### Parameters {#singlestacktreecursor-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        root
      </td>
      <td>
        TNode
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        adapter
      </td>
      <td>
        <a href='/docs/apis/tree/cursoradapter-interface'>CursorAdapter</a><TNode>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#singlestacktreecursor-returns}

an [ITreeCursorSynchronous](/docs/apis/tree/itreecursorsynchronous-interface) for a single root.

<b>Return type:</b> [CursorWithNode](/docs/apis/tree/cursorwithnode-interface)<!-- -->&lt;TNode&gt;

### singleTextCursor {#singletextcursor-function}

#### Signature {#singletextcursor-signature}

```typescript
export declare function singleTextCursor(root: JsonableTree): ITreeCursorSynchronous;
```

#### Parameters {#singletextcursor-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        root
      </td>
      <td>
        <a href='/docs/apis/tree/jsonabletree-interface'>JsonableTree</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#singletextcursor-returns}

an [ITreeCursorSynchronous](/docs/apis/tree/itreecursorsynchronous-interface) for a single [JsonableTree](/docs/apis/tree/jsonabletree-interface)<!-- -->.

<b>Return type:</b> [ITreeCursorSynchronous](/docs/apis/tree/itreecursorsynchronous-interface)

### symbolFromKey {#symbolfromkey-function}

#### Signature {#symbolfromkey-signature}

```typescript
export declare function symbolFromKey(key: GlobalFieldKey): GlobalFieldKeySymbol;
```

#### Parameters {#symbolfromkey-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        <a href='/docs/apis/tree#globalfieldkey-typealias'>GlobalFieldKey</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#symbolfromkey-returns}

a symbol to use for `key`<!-- -->.

<b>Return type:</b> [GlobalFieldKeySymbol](/docs/apis/tree#globalfieldkeysymbol-typealias)

### symbolIsFieldKey {#symbolisfieldkey-function}

#### Signature {#symbolisfieldkey-signature}

```typescript
export declare function symbolIsFieldKey(key: symbol): key is GlobalFieldKeySymbol;
```

#### Parameters {#symbolisfieldkey-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        key
      </td>
      <td>
        symbol
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#symbolisfieldkey-returns}

true iff `key` is a [GlobalFieldKeySymbol](/docs/apis/tree#globalfieldkeysymbol-typealias)<!-- -->.

<b>Return type:</b> key is [GlobalFieldKeySymbol](/docs/apis/tree#globalfieldkeysymbol-typealias)

### tagChange {#tagchange-function}

#### Signature {#tagchange-signature}

```typescript
export declare function tagChange<T>(
    change: T,
    tag: RevisionTag | undefined,
    isInverse?: boolean,
): TaggedChange<T>;
```

#### Parameters {#tagchange-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        change
      </td>
      <td>
      </td>
      <td>
        T
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        tag
      </td>
      <td>
      </td>
      <td>
        <a href='/docs/apis/tree#revisiontag-typealias'>RevisionTag</a> | undefined
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        isInverse
      </td>
      <td>
        optional
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#tagchange-returns}

<b>Return type:</b> [TaggedChange](/docs/apis/tree/taggedchange-interface)<!-- -->&lt;T&gt;

### tagInverse {#taginverse-function}

#### Signature {#taginverse-signature}

```typescript
export declare function tagInverse<T>(
    inverseChange: T,
    invertedRevision: RevisionTag | undefined,
): TaggedChange<T>;
```

#### Parameters {#taginverse-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        inverseChange
      </td>
      <td>
        T
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        invertedRevision
      </td>
      <td>
        <a href='/docs/apis/tree#revisiontag-typealias'>RevisionTag</a> | undefined
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#taginverse-returns}

<b>Return type:</b> [TaggedChange](/docs/apis/tree/taggedchange-interface)<!-- -->&lt;T&gt;

### treeSchema {#treeschema-function}

Helper for building [TreeSchema](/docs/apis/tree/treeschema-interface)<!-- -->.

#### Signature {#treeschema-signature}

```typescript
export declare function treeSchema(data: TreeSchemaBuilder): TreeSchema;
```

#### Parameters {#treeschema-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        <a href='/docs/apis/tree/treeschemabuilder-interface'>TreeSchemaBuilder</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#treeschema-returns}

<b>Return type:</b> [TreeSchema](/docs/apis/tree/treeschema-interface)

### verifyChangeRebaser {#verifychangerebaser-function}

Verifies the axioms of `ChangeRebaser` are met by the given `rebaser`<!-- -->.

#### Signature {#verifychangerebaser-signature}

```typescript
export declare function verifyChangeRebaser<TChange>(
    rebaser: ChangeRebaser<TChange>,
    changes: ReadonlySet<TChange>,
    isEquivalent: (a: TChange, b: TChange) => boolean,
): OutputType<TChange>;
```

#### Parameters {#verifychangerebaser-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        rebaser
      </td>
      <td>
        <a href='/docs/apis/tree/changerebaser-interface'>ChangeRebaser</a><TChange>
      </td>
      <td>
        The rebaser to test.
      </td>
    </tr>
    <tr>
      <td>
        changes
      </td>
      <td>
        ReadonlySet<TChange>
      </td>
      <td>
        The set of changes to use for testing the <code>rebaser</code>.
      </td>
    </tr>
    <tr>
      <td>
        isEquivalent
      </td>
      <td>
        (a: TChange, b: TChange) => boolean
      </td>
      <td>
        Used to compare whether two changes are equivalent for the purposes of this axioms.
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#verifychangerebaser-returns}

<b>Return type:</b> [OutputType](/docs/apis/tree/outputtype-interface)<!-- -->&lt;TChange&gt;

### visitDelta {#visitdelta-function}

Crawls the given `delta`<!-- -->, calling `visitor`<!-- -->'s callback for each change encountered. Each successive call to the visitor callbacks assumes that the change described by earlier calls have been applied to the document tree. For example, for a change that deletes the first and third node of a field, the visitor calls will pass indices 0 and 1 respectively.

#### Signature {#visitdelta-signature}

```typescript
export declare function visitDelta(delta: Delta.Root, visitor: DeltaVisitor): void;
```

#### Parameters {#visitdelta-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        delta
      </td>
      <td>
        Delta.Root
      </td>
      <td>
        The delta to be crawled.
      </td>
    </tr>
    <tr>
      <td>
        visitor
      </td>
      <td>
        <a href='/docs/apis/tree/deltavisitor-interface'>DeltaVisitor</a>
      </td>
      <td>
        The object to notify of the changes encountered.
      </td>
    </tr>
  </tbody>
</table>

## Variable Details

### afterChangeToken {#afterchangetoken-variable}

This `InvalidationToken` is used to indicate that the invalidation of Dependents happens after the Delta is applied to the forest. It is a workaround i.e. definitely a misuse of the invalidation system in an absence of alternative notification/eventing system.

#### Signature {#afterchangetoken-signature}

```typescript
afterChangeToken: InvalidationToken;
```

### createField {#createfield-variable}

A symbol to get the function, which creates a new field of [EditableTree](/docs/apis/tree/editabletree-interface)<!-- -->, in contexts where string keys are already in use for fields.

#### Signature {#createfield-signature}

```typescript
createField: unique symbol
```

### defaultChangeFamily {#defaultchangefamily-variable}

#### Signature {#defaultchangefamily-signature}

```typescript
defaultChangeFamily: DefaultChangeFamily;
```

### defaultSchemaPolicy {#defaultschemapolicy-variable}

FullSchemaPolicy the default field kinds, empty default fields and neverTree for the default tree schema.

This requires new node types to have explicit stored schema to exist in documents, and allows adding new global fields along with their schema at any point.

#### Signature {#defaultschemapolicy-signature}

```typescript
defaultSchemaPolicy: FullSchemaPolicy;
```

### dummyRepairDataStore {#dummyrepairdatastore-variable}

A `RepairDataStore` implementation that returns dummy content.

#### Signature {#dummyrepairdatastore-signature}

```typescript
dummyRepairDataStore: RepairDataStore;
```

### emptyField {#emptyfield-variable}

FieldSchema which is impossible to put anything in.

#### Signature {#emptyfield-signature}

```typescript
emptyField: import("../core").FieldSchema;
```

### EmptyKey {#emptykey-variable}

The empty key ("") is used for unnamed relationships, such as the indexer of an explicit array node.

This key is a hint that this field is the primary function of the node, and in some abstractions the APIs for this field should be inlined onto the node.

TODO: This has to be a LocalFieldKey since different nodes will have different FieldSchema for it. This makes it prone to collisions and suggests that this intention may be better conveyed by metadata on the TreeViewSchema.

#### Signature {#emptykey-signature}

```typescript
EmptyKey: LocalFieldKey;
```

### emptyMap {#emptymap-variable}

Empty readonly map.

#### Signature {#emptymap-signature}

```typescript
emptyMap: ReadonlyMap<never, never>
```

### emptySet {#emptyset-variable}

Empty readonly set.

#### Signature {#emptyset-signature}

```typescript
emptySet: ReadonlySet<never>
```

### genericFieldKind {#genericfieldkind-variable}

[FieldKind](/docs/apis/tree/fieldkind-class) used to represent changes to elements of a field in a field-kind-agnostic format.

#### Signature {#genericfieldkind-signature}

```typescript
genericFieldKind: FieldKind;
```

### getField {#getfield-variable}

A symbol to get the function, which returns the field of [EditableTree](/docs/apis/tree/editabletree-interface) without unwrapping, in contexts where string keys are already in use for fields.

#### Signature {#getfield-signature}

```typescript
getField: unique symbol
```

### indexSymbol {#indexsymbol-variable}

A symbol to get the index of [EditableTree](/docs/apis/tree/editabletree-interface) within its parent field in contexts where string keys are already in use for fields.

#### Signature {#indexsymbol-signature}

```typescript
indexSymbol: unique symbol
```

### jsonArray {#jsonarray-variable}

#### Signature {#jsonarray-signature}

```typescript
jsonArray: NamedTreeSchema;
```

### jsonBoolean {#jsonboolean-variable}

#### Signature {#jsonboolean-signature}

```typescript
jsonBoolean: NamedTreeSchema;
```

### jsonNull {#jsonnull-variable}

#### Signature {#jsonnull-signature}

```typescript
jsonNull: NamedTreeSchema;
```

### jsonNumber {#jsonnumber-variable}

#### Signature {#jsonnumber-signature}

```typescript
jsonNumber: NamedTreeSchema;
```

### jsonObject {#jsonobject-variable}

#### Signature {#jsonobject-signature}

```typescript
jsonObject: NamedTreeSchema;
```

### jsonRoot {#jsonroot-variable}

#### Signature {#jsonroot-signature}

```typescript
jsonRoot: FieldSchema;
```

### jsonSchemaData {#jsonschemadata-variable}

#### Signature {#jsonschemadata-signature}

```typescript
jsonSchemaData: SchemaData;
```

### jsonString {#jsonstring-variable}

#### Signature {#jsonstring-signature}

```typescript
jsonString: NamedTreeSchema;
```

### neverField {#neverfield-variable}

FieldSchema which is impossible for any data to be in schema with.

#### Signature {#neverfield-signature}

```typescript
neverField: import("../core").FieldSchema;
```

### neverTree {#nevertree-variable}

TreeSchema which is impossible for any data to be in schema with.

#### Signature {#nevertree-signature}

```typescript
neverTree: TreeSchema;
```

### noFailure {#nofailure-variable}

#### Signature {#nofailure-signature}

```typescript
noFailure: OutputType<unknown>
```

### proxyTargetSymbol {#proxytargetsymbol-variable}

A symbol for extracting target from [EditableTree](/docs/apis/tree/editabletree-interface) proxies. Useful for debugging and testing, but not part of the public API.

#### Signature {#proxytargetsymbol-signature}

```typescript
proxyTargetSymbol: unique symbol
```

### replaceField {#replacefield-variable}

A symbol to get the function, which replaces a field of [EditableTree](/docs/apis/tree/editabletree-interface)<!-- -->, in contexts where string keys are already in use for fields.

#### Signature {#replacefield-signature}

```typescript
replaceField: unique symbol
```

### rootField {#rootfield-variable}

#### Signature {#rootfield-signature}

```typescript
rootField: DetachedField;
```

### rootFieldKey {#rootfieldkey-variable}

GlobalFieldKey to use for the root of documents. TODO: if we do want to standardize on a single value for this, it likely should be namespaced or a UUID to avoid risk of collisions.

#### Signature {#rootfieldkey-signature}

```typescript
rootFieldKey: GlobalFieldKey;
```

### rootFieldKeySymbol {#rootfieldkeysymbol-variable}

#### Signature {#rootfieldkeysymbol-signature}

```typescript
rootFieldKeySymbol: GlobalFieldKeySymbol;
```

### typeNameSymbol {#typenamesymbol-variable}

A symbol to get the type name of [EditableTree](/docs/apis/tree/editabletree-interface) in contexts where string keys are already in use for fields.

#### Signature {#typenamesymbol-signature}

```typescript
typeNameSymbol: unique symbol
```

### typeSymbol {#typesymbol-variable}

A symbol to get the type of [EditableTree](/docs/apis/tree/editabletree-interface) in contexts where string keys are already in use for fields.

#### Signature {#typesymbol-signature}

```typescript
typeSymbol: unique symbol
```

### valueSymbol {#valuesymbol-variable}

A symbol to get and set the value of [EditableTree](/docs/apis/tree/editabletree-interface) in contexts where string keys are already in use for fields.

Setting the value using the simple assignment operator (`=`<!-- -->) is only supported for [PrimitiveValue](/docs/apis/tree#primitivevalue-typealias)<!-- -->s. Concurrently setting the value will follow the "last-write-wins" semantics.

#### Signature {#valuesymbol-signature}

```typescript
valueSymbol: unique symbol
```
