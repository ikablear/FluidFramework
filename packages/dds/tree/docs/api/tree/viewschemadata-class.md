{
"title": "ViewSchemaData Class",
"summary": "A collection of View information for schema, including policy.",
"kind": "Class",
"members": {
"Constructor": {
"(constructor)": "/docs/apis/tree/viewschemadata-class#_constructor_-constructor"
},
"Property": {
"adapters": "/docs/apis/tree/viewschemadata-class#adapters-property",
"policy": "/docs/apis/tree/viewschemadata-class#policy-property"
},
"Method": {
"checkCompatibility": "/docs/apis/tree/viewschemadata-class#checkcompatibility-method"
}
},
"package": "@fluid-internal/tree",
"unscopedPackageName": "tree"
}

[//]: # "Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter."

[Packages](/docs/apis/) &gt; [@fluid-internal/tree](/docs/apis/tree) &gt; [ViewSchemaData](/docs/apis/tree/viewschemadata-class)

A collection of View information for schema, including policy.

## Signature {#viewschemadata-signature}

```typescript
export declare abstract class ViewSchemaData<TPolicy extends SchemaPolicy = SchemaPolicy>
```

<b>Type parameters:</b>

-   <b>TPolicy</b>

## Constructors

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Constructor
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/viewschemadata-class#_constructor_-constructor'>(constructor)</a>
      </td>
      <td>
        Constructs a new instance of the <code>ViewSchemaData</code> class
      </td>
    </tr>
  </tbody>
</table>

## Properties

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Property
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/viewschemadata-class#adapters-property'>adapters</a>
      </td>
      <td>
        <a href='/docs/apis/tree/adapters-interface'>Adapters</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/viewschemadata-class#policy-property'>policy</a>
      </td>
      <td>
        TPolicy
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Methods

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Method
      </th>
      <th scope="col">
        Return Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/viewschemadata-class#checkcompatibility-method'>checkCompatibility</a>
      </td>
      <td>
        { read: <a href='/docs/apis/tree#compatibility-enum'>Compatibility</a>; write: <a href='/docs/apis/tree#compatibility-enum'>Compatibility</a>; writeAllowingStoredSchemaUpdates: <a href='/docs/apis/tree#compatibility-enum'>Compatibility</a>; }
      </td>
      <td>
        <p>Determines the compatibility of a stored document (based on its stored schema) with a viewer (based on its view schema).</p><p>Adapters can be provided to handle differences between the two schema. Adapters should only use to types in the <code>view</code> SchemaRepository.</p><p>TODO: this API violates the parse don't validate design philosophy. It should be wrapped with (or replaced by) a parse style API.</p>
      </td>
    </tr>
  </tbody>
</table>

## Constructor Details

### (constructor) {#_constructor_-constructor}

Constructs a new instance of the `ViewSchemaData` class

#### Signature {#_constructor_-signature}

```typescript
constructor(policy: TPolicy, adapters: Adapters);
```

#### Parameters {#_constructor_-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        policy
      </td>
      <td>
        TPolicy
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        adapters
      </td>
      <td>
        <a href='/docs/apis/tree/adapters-interface'>Adapters</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Property Details

### adapters {#adapters-property}

#### Signature {#adapters-signature}

```typescript
readonly adapters: Adapters;
```

### policy {#policy-property}

#### Signature {#policy-signature}

```typescript
readonly policy: TPolicy;
```

## Method Details

### checkCompatibility {#checkcompatibility-method}

Determines the compatibility of a stored document (based on its stored schema) with a viewer (based on its view schema).

Adapters can be provided to handle differences between the two schema. Adapters should only use to types in the `view` SchemaRepository.

TODO: this API violates the parse don't validate design philosophy. It should be wrapped with (or replaced by) a parse style API.

#### Signature {#checkcompatibility-signature}

```typescript
abstract checkCompatibility(stored: SchemaData): {
        read: Compatibility;
        write: Compatibility;
        writeAllowingStoredSchemaUpdates: Compatibility;
    };
```

#### Parameters {#checkcompatibility-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        stored
      </td>
      <td>
        <a href='/docs/apis/tree/schemadata-interface'>SchemaData</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#checkcompatibility-returns}

<b>Return type:</b> { read: [Compatibility](/docs/apis/tree#compatibility-enum)<!-- -->; write: [Compatibility](/docs/apis/tree#compatibility-enum)<!-- -->; writeAllowingStoredSchemaUpdates: [Compatibility](/docs/apis/tree#compatibility-enum)<!-- -->; }
