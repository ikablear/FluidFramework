{
"title": "EditableTree Interface",
"summary": "A tree which can be traversed and edited.\n\nWhen iterating, only visits non-empty fields. To discover empty fields, inspect the schema using [typeSymbol](/docs/apis/tree#typesymbol-variable)<!-- -->.\n\nThe tree can be inspected by means of the built-in JS functions e.g.\n\n`\nconst root = context.unwrappedRoot;\nfor (const key of Reflect.ownKeys(root)) { ... }\n// OR\nif ('foo' in root) { ... }\n`\nwhere `context` is a common `EditableTreeContext`<!-- -->.\n\nThe tree can be edited either by using its symbol-based 'toolbox' (e.g. [createField](/docs/apis/tree#createfield-variable)<!-- -->) or using a simple assignment operator (see `EditableTreeContext.unwrappedRoot` for more details).",
"kind": "Interface",
"members": {
"MethodSignature": {
"[createField]": "/docs/apis/tree/editabletree-interface#_createfield_-methodsignature",
"[getField]": "/docs/apis/tree/editabletree-interface#_getfield_-methodsignature",
"[replaceField]": "/docs/apis/tree/editabletree-interface#_replacefield_-methodsignature",
"[Symbol.iterator]": "/docs/apis/tree/editabletree-interface#_symbol.iterator_-methodsignature"
},
"PropertySignature": {
"[indexSymbol]": "/docs/apis/tree/editabletree-interface#_indexsymbol_-propertysignature",
"[proxyTargetSymbol]": "/docs/apis/tree/editabletree-interface#_proxytargetsymbol_-propertysignature",
"[typeNameSymbol]": "/docs/apis/tree/editabletree-interface#_typenamesymbol_-propertysignature",
"[typeSymbol]": "/docs/apis/tree/editabletree-interface#_typesymbol_-propertysignature",
"[valueSymbol]": "/docs/apis/tree/editabletree-interface#_valuesymbol_-propertysignature"
},
"IndexSignature": {
"(indexer)": "/docs/apis/tree/editabletree-interface#_indexer_-indexsignature"
}
},
"package": "@fluid-internal/tree",
"unscopedPackageName": "tree"
}

[//]: # "Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter."

[Packages](/docs/apis/) &gt; [@fluid-internal/tree](/docs/apis/tree) &gt; [EditableTree](/docs/apis/tree/editabletree-interface)

A tree which can be traversed and edited.

When iterating, only visits non-empty fields. To discover empty fields, inspect the schema using [typeSymbol](/docs/apis/tree#typesymbol-variable)<!-- -->.

The tree can be inspected by means of the built-in JS functions e.g.

```
const root = context.unwrappedRoot;
for (const key of Reflect.ownKeys(root)) { ... }
// OR
if ("foo" in root) { ... }
```

where `context` is a common `EditableTreeContext`<!-- -->.

The tree can be edited either by using its symbol-based "toolbox" (e.g. [createField](/docs/apis/tree#createfield-variable)<!-- -->) or using a simple assignment operator (see `EditableTreeContext.unwrappedRoot` for more details).

## Signature {#editabletree-signature}

```typescript
export interface EditableTree extends Iterable<EditableField>, ContextuallyTypedNodeDataObject
```

<b>Extends:</b> Iterable&lt;[EditableField](/docs/apis/tree/editablefield-interface)<!-- -->&gt;, [ContextuallyTypedNodeDataObject](/docs/apis/tree/contextuallytypednodedataobject-interface)

## Properties

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Property
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_indexsymbol_-propertysignature'>[indexSymbol]</a>
      </td>
      <td>
        number
      </td>
      <td>
        Index of this node within its parent field.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_proxytargetsymbol_-propertysignature'>[proxyTargetSymbol]</a>
      </td>
      <td>
        object
      </td>
      <td>
        Stores the target for the proxy which implements reading and writing for this node. The details of this object are implementation details, but the presence of this symbol can be used to separate EditableTrees from other types.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_typenamesymbol_-propertysignature'>[typeNameSymbol]</a>
      </td>
      <td>
        <a href='/docs/apis/tree#treeschemaidentifier-typealias'>TreeSchemaIdentifier</a>
      </td>
      <td>
        The name of the node type.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_typesymbol_-propertysignature'>[typeSymbol]</a>
      </td>
      <td>
        <a href='/docs/apis/tree/treeschema-interface'>TreeSchema</a>
      </td>
      <td>
        The type of the node. If this node is well-formed, it must follow this schema.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_valuesymbol_-propertysignature'>[valueSymbol]</a>
      </td>
      <td>
        <a href='/docs/apis/tree#value-typealias'>Value</a>
      </td>
      <td>
        <p>Value stored on this node.</p><p>Setting the value using the simple assignment operator (<code>=</code>) is only supported for <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>s. Concurrently setting the value will follow the "last-write-wins" semantics.</p>
      </td>
    </tr>
  </tbody>
</table>

## Methods

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Method
      </th>
      <th scope="col">
        Return Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_createfield_-methodsignature'>[createField]</a>
      </td>
      <td>
        void
      </td>
      <td>
        <p>Creates a new field at this node.</p><p>The content of the new field must follow the <a href='/docs/apis/tree#multiplicity-enum'>Multiplicity</a> of the <a href='/docs/apis/tree/fieldkind-class'>FieldKind</a>: - use a single cursor when creating an <code>optional</code> field; - use array of cursors when creating a <code>sequence</code> field; - use <a href='/docs/apis/tree/editablefield-interface#insertnodes-methodsignature'>EditableField.insertNodes()</a> instead to create fields of kind <code>value</code> as currently it is not possible to have trees with already populated fields of this kind.</p><p>When creating a field in a concurrent environment, <code>optional</code> fields will be created following the "last-write-wins" semantics, and for <code>sequence</code> fields the content ends up in order of "sequenced-last" to "sequenced-first".</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_getfield_-methodsignature'>[getField]</a>
      </td>
      <td>
        <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>
      </td>
      <td>
        Gets the field of this node by its key without unwrapping.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_replacefield_-methodsignature'>[replaceField]</a>
      </td>
      <td>
        void
      </td>
      <td>
        <p>Replaces the field of this node.</p><p>The content of the field must follow the <a href='/docs/apis/tree#multiplicity-enum'>Multiplicity</a> of the <a href='/docs/apis/tree/fieldkind-class'>FieldKind</a>: - use a single cursor when replacing an <code>optional</code> or a <code>value</code> field; - use array of cursors when replacing a <code>sequence</code> field.</p><p>Use <code>delete</code> operator to delete <code>optional</code> or <code>sequence</code> fields of this node, if any.</p><p>When replacing a field in a concurrent environment, the following merge semantics will be applied depending on the field multiplicity: - optional and value fields will be overwritten in a "last-write-wins" fashion, - for sequence fields, the nodes present in the field on the issuing client will be deleted and the newContent will be inserted. This means concurrent inserts (including calls to <code>replaceField</code>) can all contribute content. In the future this will likely be replaced with merge semantics that is more consistent with that of optional and value fields.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_symbol.iterator_-methodsignature'>[Symbol.iterator]</a>
      </td>
      <td>
        IterableIterator<<a href='/docs/apis/tree/editablefield-interface'>EditableField</a>>
      </td>
      <td>
        Gets an iterator iterating over the fields of this node. It reads all fields at once before the iteration starts to get a "snapshot" of this node. It might be inefficient regarding resources, but avoids situations when the fields are getting changed while iterating.
      </td>
    </tr>
  </tbody>
</table>

## Index Signatures

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        IndexSignature
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/editabletree-interface#_indexer_-indexsignature'>[key: FieldKey]: UnwrappedEditableField</a>
      </td>
      <td>
        <p>Fields of this node, indexed by their field keys.</p><p>This API exposes content in a way depending on the <a href='/docs/apis/tree#multiplicity-enum'>Multiplicity</a> of the <a href='/docs/apis/tree/fieldkind-class'>FieldKind</a>. Sequences (including empty ones) are always exposed as <a href='/docs/apis/tree/editablefield-interface'>EditableField</a>s, and everything else is either a single EditableTree or undefined depending on if it's empty.</p><p>It is possible to use this indexed access to delete the field using the <code>delete</code> operator and to set the value of the field or, more precisely, of its existing node using the simple assignment operator (<code>=</code>) if the field is defined as <code>optional</code> or <code>value</code>, its node <a href='/docs/apis/tree#isprimitive-function'>isPrimitive()</a> and the value is a <a href='/docs/apis/tree#primitivevalue-typealias'>PrimitiveValue</a>. Concurrently setting the value will follow the "last-write-wins" semantics.</p><p>See <code>EditableTreeContext.unwrappedRoot</code> for how to use the simple assignment operator in other cases, as it works the same way for all children of the tree starting from its root.</p>
      </td>
    </tr>
  </tbody>
</table>

## Property Details

### \[indexSymbol\] {#_indexsymbol_-propertysignature}

Index of this node within its parent field.

#### Signature {#_indexsymbol_-signature}

```typescript
readonly [indexSymbol]: number;
```

### \[proxyTargetSymbol\] {#_proxytargetsymbol_-propertysignature}

Stores the target for the proxy which implements reading and writing for this node. The details of this object are implementation details, but the presence of this symbol can be used to separate EditableTrees from other types.

#### Signature {#_proxytargetsymbol_-signature}

```typescript
readonly [proxyTargetSymbol]: object;
```

### \[typeNameSymbol\] {#_typenamesymbol_-propertysignature}

The name of the node type.

#### Signature {#_typenamesymbol_-signature}

```typescript
readonly [typeNameSymbol]: TreeSchemaIdentifier;
```

### \[typeSymbol\] {#_typesymbol_-propertysignature}

The type of the node. If this node is well-formed, it must follow this schema.

#### Signature {#_typesymbol_-signature}

```typescript
readonly [typeSymbol]: TreeSchema;
```

### \[valueSymbol\] {#_valuesymbol_-propertysignature}

Value stored on this node.

Setting the value using the simple assignment operator (`=`<!-- -->) is only supported for [PrimitiveValue](/docs/apis/tree#primitivevalue-typealias)<!-- -->s. Concurrently setting the value will follow the "last-write-wins" semantics.

#### Signature {#_valuesymbol_-signature}

```typescript
[valueSymbol]: Value;
```

## Method Details

### \[createField\] {#_createfield_-methodsignature}

Creates a new field at this node.

The content of the new field must follow the [Multiplicity](/docs/apis/tree#multiplicity-enum) of the [FieldKind](/docs/apis/tree/fieldkind-class)<!-- -->: - use a single cursor when creating an `optional` field; - use array of cursors when creating a `sequence` field; - use [EditableField.insertNodes()](/docs/apis/tree/editablefield-interface#insertnodes-methodsignature) instead to create fields of kind `value` as currently it is not possible to have trees with already populated fields of this kind.

When creating a field in a concurrent environment, `optional` fields will be created following the "last-write-wins" semantics, and for `sequence` fields the content ends up in order of "sequenced-last" to "sequenced-first".

#### Signature {#_createfield_-signature}

```typescript
[createField](fieldKey: FieldKey, newContent: ITreeCursor | ITreeCursor[]): void;
```

#### Parameters {#_createfield_-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        fieldKey
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        newContent
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a> | <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a>[]
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

### \[getField\] {#_getfield_-methodsignature}

Gets the field of this node by its key without unwrapping.

#### Signature {#_getfield_-signature}

```typescript
[getField](fieldKey: FieldKey): EditableField;
```

#### Parameters {#_getfield_-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        fieldKey
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#_getfield_-returns}

<b>Return type:</b> [EditableField](/docs/apis/tree/editablefield-interface)

### \[replaceField\] {#_replacefield_-methodsignature}

Replaces the field of this node.

The content of the field must follow the [Multiplicity](/docs/apis/tree#multiplicity-enum) of the [FieldKind](/docs/apis/tree/fieldkind-class)<!-- -->: - use a single cursor when replacing an `optional` or a `value` field; - use array of cursors when replacing a `sequence` field.

Use `delete` operator to delete `optional` or `sequence` fields of this node, if any.

When replacing a field in a concurrent environment, the following merge semantics will be applied depending on the field multiplicity: - optional and value fields will be overwritten in a "last-write-wins" fashion, - for sequence fields, the nodes present in the field on the issuing client will be deleted and the newContent will be inserted. This means concurrent inserts (including calls to `replaceField`<!-- -->) can all contribute content. In the future this will likely be replaced with merge semantics that is more consistent with that of optional and value fields.

#### Signature {#_replacefield_-signature}

```typescript
[replaceField](fieldKey: FieldKey, newContent: ITreeCursor | ITreeCursor[]): void;
```

#### Parameters {#_replacefield_-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        fieldKey
      </td>
      <td>
        <a href='/docs/apis/tree#fieldkey-typealias'>FieldKey</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        newContent
      </td>
      <td>
        <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a> | <a href='/docs/apis/tree/itreecursor-interface'>ITreeCursor</a>[]
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

### \[Symbol.iterator\] {#_symbol.iterator_-methodsignature}

Gets an iterator iterating over the fields of this node. It reads all fields at once before the iteration starts to get a "snapshot" of this node. It might be inefficient regarding resources, but avoids situations when the fields are getting changed while iterating.

#### Signature {#_symbol.iterator_-signature}

```typescript
[Symbol.iterator](): IterableIterator<EditableField>;
```

#### Returns {#_symbol.iterator_-returns}

<b>Return type:</b> IterableIterator&lt;[EditableField](/docs/apis/tree/editablefield-interface)<!-- -->&gt;

## Index Signature Details

### \[key: FieldKey\]: UnwrappedEditableField {#_indexer_-indexsignature}

Fields of this node, indexed by their field keys.

This API exposes content in a way depending on the [Multiplicity](/docs/apis/tree#multiplicity-enum) of the [FieldKind](/docs/apis/tree/fieldkind-class)<!-- -->. Sequences (including empty ones) are always exposed as [EditableField](/docs/apis/tree/editablefield-interface)<!-- -->s, and everything else is either a single EditableTree or undefined depending on if it's empty.

It is possible to use this indexed access to delete the field using the `delete` operator and to set the value of the field or, more precisely, of its existing node using the simple assignment operator (`=`<!-- -->) if the field is defined as `optional` or `value`<!-- -->, its node [isPrimitive()](/docs/apis/tree#isprimitive-function) and the value is a [PrimitiveValue](/docs/apis/tree#primitivevalue-typealias)<!-- -->. Concurrently setting the value will follow the "last-write-wins" semantics.

See `EditableTreeContext.unwrappedRoot` for how to use the simple assignment operator in other cases, as it works the same way for all children of the tree starting from its root.

#### Signature {#_indexer_-signature}

```typescript
[key: FieldKey]: UnwrappedEditableField;
```
