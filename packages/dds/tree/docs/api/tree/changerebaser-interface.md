{
"title": "ChangeRebaser Interface",
"summary": "Rebasing logic for a particular kind of change.\n\nThis interface is used to provide rebase policy to `Rebaser`<!-- -->.\n\nThe implementation must ensure TChangeset forms a \\[group\\](<https://en.wikipedia.org/wiki/Group\_(mathematics)>) where: - `compose([])` is the identity element. - associativity is defined as `compose([...a, ...b])` is equal to `compose([compose(a), compose(b)])` for all `a` and `b`<!-- -->. - `inverse(a)` gives the inverse element of `a`<!-- -->.\n\nIn these requirements the definition of equality is up to the implementer, but it is required that any two changes which are considered equal: - have the same impact when applied to any tree. - can be substituted for each-other in all methods on this interface and produce equal (by this same definition) results.\n\nFor the sake of testability, implementations will likely want to have a concrete equality implementation.\n\nThis API uses `compose` on arrays instead of an explicit identity element and associative binary operator to allow the implementation more room for optimization, but should otherwise be equivalent to the identity element and binary operator group approach.\n\nTODO: Be more specific about the above requirements. For example, would something that is close to forming a group but has precision issues (ex: the floating point numbers and addition) be ok? Would this cause decoherence (and thus be absolutely not ok), or just minor semantic precision issues, which could be tolerated. For now assume that such issues are not ok.",
"kind": "Interface",
"members": {
"PropertySignature": {
"\_typeCheck": "/docs/apis/tree/changerebaser-interface#\_typecheck-propertysignature"
},
"MethodSignature": {
"compose": "/docs/apis/tree/changerebaser-interface#compose-methodsignature",
"invert": "/docs/apis/tree/changerebaser-interface#invert-methodsignature",
"rebase": "/docs/apis/tree/changerebaser-interface#rebase-methodsignature",
"rebaseAnchors": "/docs/apis/tree/changerebaser-interface#rebaseanchors-methodsignature"
}
},
"package": "@fluid-internal/tree",
"unscopedPackageName": "tree"
}

[//]: # "Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter."

[Packages](/docs/apis/) &gt; [@fluid-internal/tree](/docs/apis/tree) &gt; [ChangeRebaser](/docs/apis/tree/changerebaser-interface)

Rebasing logic for a particular kind of change.

This interface is used to provide rebase policy to `Rebaser`<!-- -->.

The implementation must ensure TChangeset forms a \[group\](https://en.wikipedia.org/wiki/Group\_(mathematics)) where: - `compose([])` is the identity element. - associativity is defined as `compose([...a, ...b])` is equal to `compose([compose(a), compose(b)])` for all `a` and `b`<!-- -->. - `inverse(a)` gives the inverse element of `a`<!-- -->.

In these requirements the definition of equality is up to the implementer, but it is required that any two changes which are considered equal: - have the same impact when applied to any tree. - can be substituted for each-other in all methods on this interface and produce equal (by this same definition) results.

For the sake of testability, implementations will likely want to have a concrete equality implementation.

This API uses `compose` on arrays instead of an explicit identity element and associative binary operator to allow the implementation more room for optimization, but should otherwise be equivalent to the identity element and binary operator group approach.

TODO: Be more specific about the above requirements. For example, would something that is close to forming a group but has precision issues (ex: the floating point numbers and addition) be ok? Would this cause decoherence (and thus be absolutely not ok), or just minor semantic precision issues, which could be tolerated. For now assume that such issues are not ok.

## Signature {#changerebaser-signature}

```typescript
export interface ChangeRebaser<TChangeset>
```

<b>Type parameters:</b>

-   <b>TChangeset</b>

## Properties

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Property
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/changerebaser-interface#_typecheck-propertysignature'>_typeCheck</a>
      </td>
      <td>
        <code>optional</code>
      </td>
      <td>
        <a href='/docs/apis/tree/invariant-interface'>Invariant</a><TChangeset>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Methods

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Method
      </th>
      <th scope="col">
        Return Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/changerebaser-interface#compose-methodsignature'>compose</a>
      </td>
      <td>
        TChangeset
      </td>
      <td>
        Compose a collection of changesets into a single one. See <a href='/docs/apis/tree/changerebaser-interface'>ChangeRebaser</a> for requirements.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/changerebaser-interface#invert-methodsignature'>invert</a>
      </td>
      <td>
        TChangeset
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/changerebaser-interface#rebase-methodsignature'>rebase</a>
      </td>
      <td>
        TChangeset
      </td>
      <td>
        <p>Rebase <code>change</code> over <code>over</code>.</p><p>The resulting changeset should, as much as possible, replicate the same semantics as <code>change</code>, except be valid to apply after <code>over</code> instead of before it.</p><p>Requirements: The implementation must ensure that for all possible changesets <code>a</code>, <code>b</code> and <code>c</code>: - <code>rebase(a, compose([b, c])</code> is equal to <code>rebase(rebase(a, b), c)</code>. - <code>rebase(compose([a, b]), c)</code> is equal to <code>compose([rebase(a, c), rebase(b, compose([inverse(a), c, rebase(a, c)])])</code>. - <code>rebase(a, compose([]))</code> is equal to <code>a</code>. - <code>rebase(compose([]), a)</code> is equal to <code>a</code>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/changerebaser-interface#rebaseanchors-methodsignature'>rebaseAnchors</a>
      </td>
      <td>
        void
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Property Details

### \_typeCheck {#\_typecheck-propertysignature}

#### Signature {#\_typecheck-signature}

```typescript
_typeCheck?: Invariant<TChangeset>;
```

## Method Details

### compose {#compose-methodsignature}

Compose a collection of changesets into a single one. See [ChangeRebaser](/docs/apis/tree/changerebaser-interface) for requirements.

#### Signature {#compose-signature}

```typescript
compose(changes: TaggedChange<TChangeset>[]): TChangeset;
```

#### Parameters {#compose-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        changes
      </td>
      <td>
        <a href='/docs/apis/tree/taggedchange-interface'>TaggedChange</a><TChangeset>[]
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#compose-returns}

<b>Return type:</b> TChangeset

### invert {#invert-methodsignature}

#### Signature {#invert-signature}

```typescript
invert(changes: TaggedChange<TChangeset>): TChangeset;
```

#### Parameters {#invert-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        changes
      </td>
      <td>
        <a href='/docs/apis/tree/taggedchange-interface'>TaggedChange</a><TChangeset>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#invert-returns}

the inverse of `changes`<!-- -->.

`compose([changes, inverse(changes)])` be equal to `compose([])`<!-- -->: See [ChangeRebaser](/docs/apis/tree/changerebaser-interface) for details.

<b>Return type:</b> TChangeset

### rebase {#rebase-methodsignature}

Rebase `change` over `over`<!-- -->.

The resulting changeset should, as much as possible, replicate the same semantics as `change`<!-- -->, except be valid to apply after `over` instead of before it.

Requirements: The implementation must ensure that for all possible changesets `a`<!-- -->, `b` and `c`<!-- -->: - `rebase(a, compose([b, c])` is equal to `rebase(rebase(a, b), c)`<!-- -->. - `rebase(compose([a, b]), c)` is equal to `compose([rebase(a, c), rebase(b, compose([inverse(a), c, rebase(a, c)])])`<!-- -->. - `rebase(a, compose([]))` is equal to `a`<!-- -->. - `rebase(compose([]), a)` is equal to `a`<!-- -->.

#### Signature {#rebase-signature}

```typescript
rebase(change: TChangeset, over: TaggedChange<TChangeset>): TChangeset;
```

#### Parameters {#rebase-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        change
      </td>
      <td>
        TChangeset
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        over
      </td>
      <td>
        <a href='/docs/apis/tree/taggedchange-interface'>TaggedChange</a><TChangeset>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#rebase-returns}

<b>Return type:</b> TChangeset

### rebaseAnchors {#rebaseanchors-methodsignature}

#### Signature {#rebaseanchors-signature}

```typescript
rebaseAnchors(anchors: AnchorSet, over: TChangeset): void;
```

#### Parameters {#rebaseanchors-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        anchors
      </td>
      <td>
        <a href='/docs/apis/tree/anchorset-class'>AnchorSet</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        over
      </td>
      <td>
        TChangeset
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>
