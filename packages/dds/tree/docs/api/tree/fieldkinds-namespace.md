{
"title": "FieldKinds Namespace",
"kind": "Namespace",
"members": {
"Variable": {
"counter": "/docs/apis/tree/fieldkinds-namespace#counter-variable",
"counterHandle": "/docs/apis/tree/fieldkinds-namespace#counterhandle-variable",
"fieldKinds": "/docs/apis/tree/fieldkinds-namespace#fieldkinds-variable",
"forbidden": "/docs/apis/tree/fieldkinds-namespace#forbidden-variable",
"noChangeHandler": "/docs/apis/tree/fieldkinds-namespace#nochangehandler-variable",
"optional": "/docs/apis/tree/fieldkinds-namespace#optional-variable",
"sequence": "/docs/apis/tree/fieldkinds-namespace#sequence-variable",
"value": "/docs/apis/tree/fieldkinds-namespace#value-variable"
},
"Function": {
"lastWriteWinsRebaser": "/docs/apis/tree/fieldkinds-namespace#lastwritewinsrebaser-function",
"replaceRebaser": "/docs/apis/tree/fieldkinds-namespace#replacerebaser-function"
},
"TypeAlias": {
"NodeUpdate": "/docs/apis/tree/fieldkinds-namespace#nodeupdate-typealias",
"ReplaceOp": "/docs/apis/tree/fieldkinds-namespace#replaceop-typealias"
},
"Interface": {
"OptionalChangeset": "/docs/apis/tree/fieldkinds/optionalchangeset-interface",
"OptionalFieldChange": "/docs/apis/tree/fieldkinds/optionalfieldchange-interface",
"OptionalFieldEditor": "/docs/apis/tree/fieldkinds/optionalfieldeditor-interface",
"Replacement": "/docs/apis/tree/fieldkinds/replacement-interface",
"ValueChangeset": "/docs/apis/tree/fieldkinds/valuechangeset-interface",
"ValueFieldEditor": "/docs/apis/tree/fieldkinds/valuefieldeditor-interface"
},
"Class": {
"UnitEncoder": "/docs/apis/tree/fieldkinds/unitencoder-class",
"ValueEncoder": "/docs/apis/tree/fieldkinds/valueencoder-class"
}
},
"package": "@fluid-internal/tree",
"unscopedPackageName": "tree"
}

[//]: # "Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter."

[Packages](/docs/apis/) &gt; [@fluid-internal/tree](/docs/apis/tree) &gt; [FieldKinds](/docs/apis/tree/fieldkinds-namespace)

## Interfaces

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Interface
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds/optionalchangeset-interface'>OptionalChangeset</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds/optionalfieldchange-interface'>OptionalFieldChange</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds/optionalfieldeditor-interface'>OptionalFieldEditor</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds/replacement-interface'>Replacement</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds/valuechangeset-interface'>ValueChangeset</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds/valuefieldeditor-interface'>ValueFieldEditor</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Classes

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Class
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds/unitencoder-class'>UnitEncoder</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        Encoder for changesets which carry no information.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds/valueencoder-class'>ValueEncoder</a>
      </td>
      <td>
        <code>sealed</code>
      </td>
      <td>
        Encoder for changesets which are just a json compatible value.
      </td>
    </tr>
  </tbody>
</table>

## Types

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        TypeAlias
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#nodeupdate-typealias'>NodeUpdate</a>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#replaceop-typealias'>ReplaceOp</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Functions

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Function
      </th>
      <th scope="col">
        Return Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#lastwritewinsrebaser-function'>lastWriteWinsRebaser</a>
      </td>
      <td>
        <a href='/docs/apis/tree/fieldchangerebaser-interface'>FieldChangeRebaser</a><TChange>
      </td>
      <td>
        <p>Picks the last value written.</p><p>TODO: it seems impossible for this to obey the desired axioms. Specifically inverse needs to cancel, restoring the value from the previous change which was discarded.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#replacerebaser-function'>replaceRebaser</a>
      </td>
      <td>
        <a href='/docs/apis/tree/fieldchangerebaser-interface'>FieldChangeRebaser</a><ReplaceOp<T>>
      </td>
      <td>
        <p>Picks the last value written.</p><p>Consistent if used on valid paths with correct old states.</p>
      </td>
    </tr>
  </tbody>
</table>

## Variables

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Variable
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#counter-variable'>counter</a>
      </td>
      <td>
        <p>Field kind for counters. Stores a single value which corresponds to number which can be added to.</p><p>This is an example of a few interesting things:</p><p>- A field kind with some constraints on what can be under it type wise. Other possible examples which would do this include sets, maps (for their keys), or any domain specific specialized kinds.</p><p>- A field kind with commutative edits.</p><p>TODO: What should the subtrees under this look like? How does it prevent / interact with direct edits to the subtree (ex: set value)? How should it use its type set? How should it handle lack of associative addition due to precision and overflow?</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#counterhandle-variable'>counterHandle</a>
      </td>
      <td>
        <p>ChangeHandler that does not support any changes.</p><p>TODO: Due to floating point precision compose is not quite associative. This may violate our requirements. This could be fixed by making this integer only and handling values past Number.MAX_SAFE_INTEGER (ex: via an arbitrarily large integer library) or via modular arithmetic.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#fieldkinds-variable'>fieldKinds</a>
      </td>
      <td>
        Default field kinds by identifier
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#forbidden-variable'>forbidden</a>
      </td>
      <td>
        <p>Exactly 0 items.</p><p>Using Forbidden makes what types are listed for allowed in a field irrelevant since the field will never have values in it.</p><p>Using Forbidden is equivalent to picking a kind that permits empty (like sequence or optional) and having no allowed types (or only never types). Because of this, its possible to express everything constraint wise without Forbidden, but using Forbidden can be more semantically clear than optional with no allowed types.</p><p>For view schema, this can be useful if you need to: - run a specific out of schema handler when a field is present, but otherwise are ignoring or tolerating (ex: via extra fields) unmentioned fields. - prevent a specific field from being used as an extra field (perhaps for some past of future compatibility reason) - keep a field in a schema for metadata purposes (ex: for improved error messaging, error handling or documentation) that is not used in this specific version of the schema (ex: to document what it was or will be used for).</p><p>For stored schema, this can be useful if you need to: - have a field which can have its schema updated to Optional or Sequence of any type. - to exclude a field from extra fields - for the schema system to use as a default for fields which aren't declared (ex: when updating a field that did not exist into one that does)</p><p>See <a href='/docs/apis/tree#emptyfield-variable'>emptyField</a> for a constant, reusable field using Forbidden.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#nochangehandler-variable'>noChangeHandler</a>
      </td>
      <td>
        ChangeHandler that only handles no-op / identity changes.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#optional-variable'>optional</a>
      </td>
      <td>
        0 or 1 items.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#sequence-variable'>sequence</a>
      </td>
      <td>
        0 or more items.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/fieldkinds-namespace#value-variable'>value</a>
      </td>
      <td>
        Exactly one item.
      </td>
    </tr>
  </tbody>
</table>

## Type Details

### NodeUpdate {#nodeupdate-typealias}

#### Signature {#nodeupdate-signature}

```typescript
export declare type NodeUpdate =
    | {
          set: JsonableTree;
      }
    | {
          revert: RevisionTag | undefined;
      };
```

### ReplaceOp {#replaceop-typealias}

#### Signature {#replaceop-signature}

```typescript
export declare type ReplaceOp<T> = Replacement<T> | 0;
```

## Function Details

### lastWriteWinsRebaser {#lastwritewinsrebaser-function}

Picks the last value written.

TODO: it seems impossible for this to obey the desired axioms. Specifically inverse needs to cancel, restoring the value from the previous change which was discarded.

#### Signature {#lastwritewinsrebaser-signature}

```typescript
export declare function lastWriteWinsRebaser<TChange>(data: {
    noop: TChange;
    invert: (changes: TChange) => TChange;
}): FieldChangeRebaser<TChange>;
```

#### Parameters {#lastwritewinsrebaser-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        data
      </td>
      <td>
        { noop: TChange; invert: (changes: TChange) => TChange; }
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#lastwritewinsrebaser-returns}

<b>Return type:</b> [FieldChangeRebaser](/docs/apis/tree/fieldchangerebaser-interface)<!-- -->&lt;TChange&gt;

### replaceRebaser {#replacerebaser-function}

Picks the last value written.

Consistent if used on valid paths with correct old states.

#### Signature {#replacerebaser-signature}

```typescript
export declare function replaceRebaser<T>(): FieldChangeRebaser<ReplaceOp<T>>;
```

#### Returns {#replacerebaser-returns}

<b>Return type:</b> [FieldChangeRebaser](/docs/apis/tree/fieldchangerebaser-interface)<!-- -->&lt;ReplaceOp&lt;T&gt;&gt;

## Variable Details

### counter {#counter-variable}

Field kind for counters. Stores a single value which corresponds to number which can be added to.

This is an example of a few interesting things:

-   A field kind with some constraints on what can be under it type wise. Other possible examples which would do this include sets, maps (for their keys), or any domain specific specialized kinds.

-   A field kind with commutative edits.

TODO: What should the subtrees under this look like? How does it prevent / interact with direct edits to the subtree (ex: set value)? How should it use its type set? How should it handle lack of associative addition due to precision and overflow?

#### Signature {#counter-signature}

```typescript
counter: FieldKind;
```

### counterHandle {#counterhandle-variable}

ChangeHandler that does not support any changes.

TODO: Due to floating point precision compose is not quite associative. This may violate our requirements. This could be fixed by making this integer only and handling values past Number.MAX_SAFE_INTEGER (ex: via an arbitrarily large integer library) or via modular arithmetic.

#### Signature {#counterhandle-signature}

```typescript
counterHandle: FieldChangeHandler<number>
```

### fieldKinds {#fieldkinds-variable}

Default field kinds by identifier

#### Signature {#fieldkinds-signature}

```typescript
fieldKinds: ReadonlyMap<FieldKindIdentifier, FieldKind>
```

### forbidden {#forbidden-variable}

Exactly 0 items.

Using Forbidden makes what types are listed for allowed in a field irrelevant since the field will never have values in it.

Using Forbidden is equivalent to picking a kind that permits empty (like sequence or optional) and having no allowed types (or only never types). Because of this, its possible to express everything constraint wise without Forbidden, but using Forbidden can be more semantically clear than optional with no allowed types.

For view schema, this can be useful if you need to: - run a specific out of schema handler when a field is present, but otherwise are ignoring or tolerating (ex: via extra fields) unmentioned fields. - prevent a specific field from being used as an extra field (perhaps for some past of future compatibility reason) - keep a field in a schema for metadata purposes (ex: for improved error messaging, error handling or documentation) that is not used in this specific version of the schema (ex: to document what it was or will be used for).

For stored schema, this can be useful if you need to: - have a field which can have its schema updated to Optional or Sequence of any type. - to exclude a field from extra fields - for the schema system to use as a default for fields which aren't declared (ex: when updating a field that did not exist into one that does)

See [emptyField](/docs/apis/tree#emptyfield-variable) for a constant, reusable field using Forbidden.

#### Signature {#forbidden-signature}

```typescript
forbidden: FieldKind;
```

### noChangeHandler {#nochangehandler-variable}

ChangeHandler that only handles no-op / identity changes.

#### Signature {#nochangehandler-signature}

```typescript
noChangeHandler: FieldChangeHandler<0>
```

### optional {#optional-variable}

0 or 1 items.

#### Signature {#optional-signature}

```typescript
optional: FieldKind<OptionalFieldEditor>
```

### sequence {#sequence-variable}

0 or more items.

#### Signature {#sequence-signature}

```typescript
sequence: FieldKind<SequenceFieldEditor>
```

### value {#value-variable}

Exactly one item.

#### Signature {#value-signature}

```typescript
value: FieldKind<ValueFieldEditor>
```
