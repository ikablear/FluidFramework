{
"title": "TreeSchema Interface",
"kind": "Interface",
"members": {
"PropertySignature": {
"extraGlobalFields": "/docs/apis/tree/treeschema-interface#extraglobalfields-propertysignature",
"extraLocalFields": "/docs/apis/tree/treeschema-interface#extralocalfields-propertysignature",
"globalFields": "/docs/apis/tree/treeschema-interface#globalfields-propertysignature",
"localFields": "/docs/apis/tree/treeschema-interface#localfields-propertysignature",
"value": "/docs/apis/tree/treeschema-interface#value-propertysignature"
}
},
"package": "@fluid-internal/tree",
"unscopedPackageName": "tree"
}

[//]: # "Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter."

[Packages](/docs/apis/) &gt; [@fluid-internal/tree](/docs/apis/tree) &gt; [TreeSchema](/docs/apis/tree/treeschema-interface)

## Signature {#treeschema-signature}

```typescript
export interface TreeSchema
```

## Properties

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Property
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/treeschema-interface#extraglobalfields-propertysignature'>extraGlobalFields</a>
      </td>
      <td>
        boolean
      </td>
      <td>
        <p>If true, GlobalFieldKeys other than the ones listed above in globalFields may be used to store data on this tree node. Such fields must still be in schema with their global FieldSchema.</p><p>This allows for the "augmentations" pattern where users can attach information they understand to any tree without risk of name collisions. This is not the only way to do "augmentations": another approach is for the applications that wish to add them to include the augmentation in their view schema on the nodes they with to augment, and update the stored schema to permit them as needed.</p><p>This schema system could work with extraGlobalFields unconditionally on (justified as allowing augmentations everywhere though requiring stored schema changes), or unconditionally off (requiring augmentations to sometimes update stored schema). Simplifying this system to not have extraGlobalFields and default it to on or off is a design decision which doesn't impact the rest of this system, and thus is being put off for now.</p><p>Unlike with extraLocalFields, only non-empty global fields have to be in schema here, so the existence of a global value field does not immediately make all TreeSchema permitting extra global fields out of schema if they are missing said field.</p><p>TODO: this approach is inconsistent and should likely be redesigned so global and local extra fields work more similarly.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treeschema-interface#extralocalfields-propertysignature'>extraLocalFields</a>
      </td>
      <td>
        <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>
      </td>
      <td>
        <p>Constraint for local fields not mentioned in <code>localFields</code>.</p><p>Allows using using the local fields as a map, with the keys being LocalFieldKeys and the values being constrained by this FieldSchema.</p><p>To forbid this map like usage, use <a href='/docs/apis/tree#emptyfield-variable'>emptyField</a> here.</p><p>Usually <code>FieldKind.Value</code> should NOT be used here since no nodes can ever be in schema are in schema if you use <code>FieldKind.Value</code> here (that would require infinite children). This pattern, which produces a schema which can never be met, is used by <a href='/docs/apis/tree#nevertree-variable'>neverTree</a>, and can be useful in special cases (like a default stored schema when none is specified).</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treeschema-interface#globalfields-propertysignature'>globalFields</a>
      </td>
      <td>
        ReadonlySet<<a href='/docs/apis/tree#globalfieldkey-typealias'>GlobalFieldKey</a>>
      </td>
      <td>
        <p>Schema for fields with keys scoped to the whole document.</p><p>Having a centralized map indexed by FieldSchemaIdentifier can be used for fields which have the same meaning in multiple places, and simplifies document root handling (since the root can just have a special <code>FieldSchemaIdentifier</code>).</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treeschema-interface#localfields-propertysignature'>localFields</a>
      </td>
      <td>
        ReadonlyMap<<a href='/docs/apis/tree#localfieldkey-typealias'>LocalFieldKey</a>, <a href='/docs/apis/tree/fieldschema-interface'>FieldSchema</a>>
      </td>
      <td>
        <p>Schema for fields with keys scoped to this TreeSchema.</p><p>This refers to the FieldSchema directly (as opposed to just supporting FieldSchemaIdentifier and having a central FieldKey -<!-- -->> FieldSchema map). This allows os short friendly field keys which can ergonomically used as field names in code. It also interoperates well with extraLocalFields being used as a map with arbitrary data as keys.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/treeschema-interface#value-propertysignature'>value</a>
      </td>
      <td>
        <a href='/docs/apis/tree#valueschema-enum'>ValueSchema</a>
      </td>
      <td>
        <p>There are several approaches for how to store actual data in the tree (special node types, special field contents, data on nodes etc.) as well as several options about how the data should be modeled at this level (byte sequence? javascript type? json?), as well as options for how much of this would be exposed in the schema language (ex: would all nodes with values be special built-ins, or could any schema add them?)</p><p>A simple easy to do in javascript approach is taken here: this is not intended to be a suggestion of what approach to take, or what to expose in the schema language. This is simply one approach that can work for modeling them in the internal schema representation.</p>
      </td>
    </tr>
  </tbody>
</table>

## Property Details

### extraGlobalFields {#extraglobalfields-propertysignature}

If true, GlobalFieldKeys other than the ones listed above in globalFields may be used to store data on this tree node. Such fields must still be in schema with their global FieldSchema.

This allows for the "augmentations" pattern where users can attach information they understand to any tree without risk of name collisions. This is not the only way to do "augmentations": another approach is for the applications that wish to add them to include the augmentation in their view schema on the nodes they with to augment, and update the stored schema to permit them as needed.

This schema system could work with extraGlobalFields unconditionally on (justified as allowing augmentations everywhere though requiring stored schema changes), or unconditionally off (requiring augmentations to sometimes update stored schema). Simplifying this system to not have extraGlobalFields and default it to on or off is a design decision which doesn't impact the rest of this system, and thus is being put off for now.

Unlike with extraLocalFields, only non-empty global fields have to be in schema here, so the existence of a global value field does not immediately make all TreeSchema permitting extra global fields out of schema if they are missing said field.

TODO: this approach is inconsistent and should likely be redesigned so global and local extra fields work more similarly.

#### Signature {#extraglobalfields-signature}

```typescript
readonly extraGlobalFields: boolean;
```

### extraLocalFields {#extralocalfields-propertysignature}

Constraint for local fields not mentioned in `localFields`<!-- -->.

Allows using using the local fields as a map, with the keys being LocalFieldKeys and the values being constrained by this FieldSchema.

To forbid this map like usage, use [emptyField](/docs/apis/tree#emptyfield-variable) here.

Usually `FieldKind.Value` should NOT be used here since no nodes can ever be in schema are in schema if you use `FieldKind.Value` here (that would require infinite children). This pattern, which produces a schema which can never be met, is used by [neverTree](/docs/apis/tree#nevertree-variable)<!-- -->, and can be useful in special cases (like a default stored schema when none is specified).

#### Signature {#extralocalfields-signature}

```typescript
readonly extraLocalFields: FieldSchema;
```

### globalFields {#globalfields-propertysignature}

Schema for fields with keys scoped to the whole document.

Having a centralized map indexed by FieldSchemaIdentifier can be used for fields which have the same meaning in multiple places, and simplifies document root handling (since the root can just have a special `FieldSchemaIdentifier`<!-- -->).

#### Signature {#globalfields-signature}

```typescript
readonly globalFields: ReadonlySet<GlobalFieldKey>;
```

### localFields {#localfields-propertysignature}

Schema for fields with keys scoped to this TreeSchema.

This refers to the FieldSchema directly (as opposed to just supporting FieldSchemaIdentifier and having a central FieldKey -<!-- -->&gt; FieldSchema map). This allows os short friendly field keys which can ergonomically used as field names in code. It also interoperates well with extraLocalFields being used as a map with arbitrary data as keys.

#### Signature {#localfields-signature}

```typescript
readonly localFields: ReadonlyMap<LocalFieldKey, FieldSchema>;
```

### value {#value-propertysignature}

There are several approaches for how to store actual data in the tree (special node types, special field contents, data on nodes etc.) as well as several options about how the data should be modeled at this level (byte sequence? javascript type? json?), as well as options for how much of this would be exposed in the schema language (ex: would all nodes with values be special built-ins, or could any schema add them?)

A simple easy to do in javascript approach is taken here: this is not intended to be a suggestion of what approach to take, or what to expose in the schema language. This is simply one approach that can work for modeling them in the internal schema representation.

#### Signature {#value-signature}

```typescript
readonly value: ValueSchema;
```
