{
"title": "DisposingDependee Class",
"summary": "A [Dependee](/docs/apis/tree/dependee-interface) which runs a callback once it removes its last dependent. See [DisposingDependee.endInitialization()](/docs/apis/tree/disposingdependee-class#endinitialization-method)<!-- -->.",
"kind": "Class",
"members": {
"Constructor": {
"(constructor)": "/docs/apis/tree/disposingdependee-class#_constructor_-constructor"
},
"Property": {
"computationName": "/docs/apis/tree/disposingdependee-class#computationname-property"
},
"Method": {
"endInitialization": "/docs/apis/tree/disposingdependee-class#endinitialization-method",
"invalidateDependents": "/docs/apis/tree/disposingdependee-class#invalidatedependents-method",
"isDisposed": "/docs/apis/tree/disposingdependee-class#isdisposed-method",
"registerDependent": "/docs/apis/tree/disposingdependee-class#registerdependent-method",
"removeDependent": "/docs/apis/tree/disposingdependee-class#removedependent-method"
}
},
"package": "@fluid-internal/tree",
"unscopedPackageName": "tree"
}

[//]: # "Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter."

[Packages](/docs/apis/) &gt; [@fluid-internal/tree](/docs/apis/tree) &gt; [DisposingDependee](/docs/apis/tree/disposingdependee-class)

A [Dependee](/docs/apis/tree/dependee-interface) which runs a callback once it removes its last dependent. See [DisposingDependee.endInitialization()](/docs/apis/tree/disposingdependee-class#endinitialization-method)<!-- -->.

## Signature {#disposingdependee-signature}

```typescript
export declare class DisposingDependee implements Dependee
```

<b>Implements:</b> [Dependee](/docs/apis/tree/dependee-interface)

## Constructors

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Constructor
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/disposingdependee-class#_constructor_-constructor'>(constructor)</a>
      </td>
      <td>
        Constructs a DisposingDependee in "initialization mode". After adding any initial dependencies, <a href='/docs/apis/tree/disposingdependee-class#endinitialization-method'>DisposingDependee.endInitialization()</a> can be called to provide an onDispose callback.
      </td>
    </tr>
  </tbody>
</table>

## Properties

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Property
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/disposingdependee-class#computationname-property'>computationName</a>
      </td>
      <td>
        string
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Methods

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Method
      </th>
      <th scope="col">
        Return Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/disposingdependee-class#endinitialization-method'>endInitialization</a>
      </td>
      <td>
        void
      </td>
      <td>
        <p>Ends "initialization mode", meaning this will now be disposed (and thus run the <code>onDispose</code> callback) the next time it has zero dependents (which will be before this returns if it currently has zero dependents).</p><p>Note that once there are zero dependents (before running the <code>onDispose</code> callback), this object is no longer usable as a Dependee, and thus it is an error to call <code>registerDependent</code>. This means <code>onDispose</code> will be invoked at most once.</p><p>It is an error to call <code>endInitialization</code> more than once. If called, it should be called by the creator of this DisposingDependee after adding initial dependencies.</p><p>"initialization mode" exists to handle a couple of edge cases where the simpler approach of just disposing when last dependee is removed would not work: - No dependents were added in initialization: would never get disposed. - A dependent was added, then removed, then a second one added during initialization: the second dependent would be added after this was disposed, which is invalid.</p><p>This first case is actually pretty easy to hit on accident even in a lazy system, since sometimes the context which takes the dependency does not need dependency tracking (ex: its a one time event and not a projection). This scenario is the main motivating factor behind this particular API design.</p><p>Another way to think about this is "initialization mode" effectively holds an extra ref count to this Dependee, keeping it alive while its in-scope for its creator to add dependents to.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/disposingdependee-class#invalidatedependents-method'>invalidateDependents</a>
      </td>
      <td>
        void
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/disposingdependee-class#isdisposed-method'>isDisposed</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/disposingdependee-class#registerdependent-method'>registerDependent</a>
      </td>
      <td>
        boolean
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/disposingdependee-class#removedependent-method'>removeDependent</a>
      </td>
      <td>
        void
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Constructor Details

### (constructor) {#_constructor_-constructor}

Constructs a DisposingDependee in "initialization mode". After adding any initial dependencies, [DisposingDependee.endInitialization()](/docs/apis/tree/disposingdependee-class#endinitialization-method) can be called to provide an onDispose callback.

#### Signature {#_constructor_-signature}

```typescript
constructor(computationName: string);
```

#### Parameters {#_constructor_-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        computationName
      </td>
      <td>
        string
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Property Details

### computationName {#computationname-property}

#### Signature {#computationname-signature}

```typescript
readonly computationName: string;
```

## Method Details

### endInitialization {#endinitialization-method}

Ends "initialization mode", meaning this will now be disposed (and thus run the `onDispose` callback) the next time it has zero dependents (which will be before this returns if it currently has zero dependents).

Note that once there are zero dependents (before running the `onDispose` callback), this object is no longer usable as a Dependee, and thus it is an error to call `registerDependent`<!-- -->. This means `onDispose` will be invoked at most once.

It is an error to call `endInitialization` more than once. If called, it should be called by the creator of this DisposingDependee after adding initial dependencies.

"initialization mode" exists to handle a couple of edge cases where the simpler approach of just disposing when last dependee is removed would not work: - No dependents were added in initialization: would never get disposed. - A dependent was added, then removed, then a second one added during initialization: the second dependent would be added after this was disposed, which is invalid.

This first case is actually pretty easy to hit on accident even in a lazy system, since sometimes the context which takes the dependency does not need dependency tracking (ex: its a one time event and not a projection). This scenario is the main motivating factor behind this particular API design.

Another way to think about this is "initialization mode" effectively holds an extra ref count to this Dependee, keeping it alive while its in-scope for its creator to add dependents to.

#### Signature {#endinitialization-signature}

```typescript
endInitialization(onDispose: (dependee: DisposingDependee) => void): void;
```

#### Parameters {#endinitialization-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        onDispose
      </td>
      <td>
        (dependee: <a href='/docs/apis/tree/disposingdependee-class'>DisposingDependee</a>) => void
      </td>
      <td>
        run once there are no dependents. Will be during this call to endInitialization if there are currently no dependents.
      </td>
    </tr>
  </tbody>
</table>

### invalidateDependents {#invalidatedependents-method}

#### Signature {#invalidatedependents-signature}

```typescript
invalidateDependents(): void;
```

### isDisposed {#isdisposed-method}

#### Signature {#isdisposed-signature}

```typescript
isDisposed(): boolean;
```

#### Returns {#isdisposed-returns}

true iff this is disposed, and this can no longer be used.

<b>Return type:</b> boolean

### registerDependent {#registerdependent-method}

#### Signature {#registerdependent-signature}

```typescript
registerDependent(dependent: Dependent): boolean;
```

#### Parameters {#registerdependent-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        dependent
      </td>
      <td>
        <a href='/docs/apis/tree/dependent-interface'>Dependent</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

#### Returns {#registerdependent-returns}

<b>Return type:</b> boolean

### removeDependent {#removedependent-method}

#### Signature {#removedependent-signature}

```typescript
removeDependent(dependent: Dependent): void;
```

#### Parameters {#removedependent-parameters}

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Parameter
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        dependent
      </td>
      <td>
        <a href='/docs/apis/tree/dependent-interface'>Dependent</a>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>
