{
"title": "NamedComputation Interface",
"summary": "Computation, with a name.",
"kind": "Interface",
"members": {
"PropertySignature": {
"computationName": "/docs/apis/tree/namedcomputation-interface#computationname-propertysignature"
},
"MethodSignature": {
"listDependees": "/docs/apis/tree/namedcomputation-interface#listdependees-methodsignature",
"listDependents": "/docs/apis/tree/namedcomputation-interface#listdependents-methodsignature"
}
},
"package": "@fluid-internal/tree",
"unscopedPackageName": "tree"
}

[//]: # "Do not edit this file. It is automatically generated by @fluidtools/api-markdown-documenter."

[Packages](/docs/apis/) &gt; [@fluid-internal/tree](/docs/apis/tree) &gt; [NamedComputation](/docs/apis/tree/namedcomputation-interface)

Computation, with a name.

## Signature {#namedcomputation-signature}

```typescript
export interface NamedComputation
```

## Properties

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Property
      </th>
      <th scope="col">
        Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/namedcomputation-interface#computationname-propertysignature'>computationName</a>
      </td>
      <td>
        string
      </td>
      <td>
        A developer-friendly description of the computation this Cell represents. Typically a function name: should be a constant which can be located by searching the source. This name should not be relied on for semantic purposes, and must be safe to log. Use when measuring / debugging / logging computation costs, invalidation etc.
      </td>
    </tr>
  </tbody>
</table>

## Methods

<table class="table table-striped table-hover">
  <thead>
    <tr>
      <th scope="col">
        Method
      </th>
      <th scope="col">
        Modifiers
      </th>
      <th scope="col">
        Return Type
      </th>
      <th scope="col">
        Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href='/docs/apis/tree/namedcomputation-interface#listdependees-methodsignature'>listDependees</a>
      </td>
      <td>
        <code>optional</code>
      </td>
      <td>
        Iterable<<a href='/docs/apis/tree/dependee-interface'>Dependee</a>>
      </td>
      <td>
        Lists the currently subscribed set of Dependees. This is exposed to allow tooling to inspect the dependency graph, and should not be needed for regular functionality. Implementing this is not required: absence of an implementation does not mean there are no dependees.
      </td>
    </tr>
    <tr>
      <td>
        <a href='/docs/apis/tree/namedcomputation-interface#listdependents-methodsignature'>listDependents</a>
      </td>
      <td>
        <code>optional</code>
      </td>
      <td>
        Iterable<<a href='/docs/apis/tree/dependent-interface'>Dependent</a>>
      </td>
      <td>
        Lists the currently subscribed set of Dependent. This is exposed to allow tooling to inspect the dependency graph, and should not be needed for regular functionality. Implementing this is not required: absence of an implementation does not mean there are no dependents.
      </td>
    </tr>
  </tbody>
</table>

## Property Details

### computationName {#computationname-propertysignature}

A developer-friendly description of the computation this Cell represents. Typically a function name: should be a constant which can be located by searching the source. This name should not be relied on for semantic purposes, and must be safe to log. Use when measuring / debugging / logging computation costs, invalidation etc.

#### Signature {#computationname-signature}

```typescript
readonly computationName: string;
```

## Method Details

### listDependees {#listdependees-methodsignature}

Lists the currently subscribed set of Dependees. This is exposed to allow tooling to inspect the dependency graph, and should not be needed for regular functionality. Implementing this is not required: absence of an implementation does not mean there are no dependees.

#### Signature {#listdependees-signature}

```typescript
listDependees?(): Iterable<Dependee>;
```

#### Returns {#listdependees-returns}

<b>Return type:</b> Iterable&lt;[Dependee](/docs/apis/tree/dependee-interface)<!-- -->&gt;

### listDependents {#listdependents-methodsignature}

Lists the currently subscribed set of Dependent. This is exposed to allow tooling to inspect the dependency graph, and should not be needed for regular functionality. Implementing this is not required: absence of an implementation does not mean there are no dependents.

#### Signature {#listdependents-signature}

```typescript
listDependents?(): Iterable<Dependent>;
```

#### Returns {#listdependents-returns}

<b>Return type:</b> Iterable&lt;[Dependent](/docs/apis/tree/dependent-interface)<!-- -->&gt;
